### **“Wide” format**
Data are often entered and stored in a “wide” format - where a subject’s characteristics or responses are stored in a single row. While this may be useful for presentation, it is not ideal for some types of analysis.

Let us take the `malaria_counts` dataset as an example. You can see that each row represents a “facility-day”. The actual case counts (the right-most columns) are stored in a “wide” format such that the information for every age group on a given facility-day is stored in a single row.

```{r}
head(malaria_counts,5)
```

Each observation in this dataset refers to the malaria counts at one of 65 facilities on a given date, ranging from `r malaria_counts$data_date %>% min()` to `r malaria_counts$data_date %>% max()`. These facilities are located in one `Province` (North) and four `Districts` (Spring, Bolo, Dingo, and Barnard). The dataset provides the overall counts of malaria, as well as age-specific counts in each of three age groups - <4 years, 5-14 years, and 15 years and older.

“Wide” data like this are not adhering to “tidy data” standards, because the column headers do not actually represent “variables” - they represent values of a hypothetical “age group” variable.

This format can be useful for presenting the information in a table, or for entering data (e.g. in Excel) from case report forms. However, in the analysis stage, these data typically should be transformed to a “longer” format more aligned with “tidy data” standards. The plotting R package **ggplot2** in particular works best when data are in a “long” format.

```{r quiz-pivot-plot}
quiz(
  question("With the original dataset format as shown above, which of the following could we easily plot?",
           answer("The *total* malaria case counts over time", correct = TRUE),
           answer("The *total* malaria case counts over time with relative contributions of each age group"),
           answer("Malaria case counts in children aged 5-14 years over time in each district", correct = TRUE),
           allow_retry = TRUE
  )
)
```

### *Answer*
Visualising the *total* malaria counts over time poses no difficulty with the data in it’s current format, as we are plotting one column against another:
  ```{r, echo=T}
ggplot(malaria_counts) +
  geom_col(aes(x = data_date, y = malaria_tot), width = 1)
```

The same principle applies to malaria case counts in children aged 5-14 years, as we are still plotting one column against another. To see which district cases originated from, we can add a colour element by adding the `fill` argument to the “mapping aesthetics” `aes()` argument:
  
  ```{r, echo=T, message=F}
ggplot(malaria_counts) +
  geom_col(aes(x = data_date, y = `malaria_rdt_5-14`,
               fill=District), width = 1)
```

As the different district names are recorded in the same column, it is easy to add this element to the plot.
But what if we wanted to display the relative contributions of each age group to this total count? In this case, we need to ensure that the variable of interest (age group), appears in the dataset in a single column (as is the case for the `Districts`) that can be passed to ggplot2’s “mapping aesthetics” `aes()` argument.

### `pivot_longer()`
The **tidyr** function `pivot_longer()` makes data “longer”. **tidyr** is part of the **tidyverse** of R packages.

It accepts a range of columns to transform (specified to `cols =`). Therefore, it can operate on only a part of a dataset. This is useful for the malaria data, as we only want to pivot the case count columns.

In this process, you will end up with two “new” columns - one with the categories (the former column names), and one with the corresponding values (e.g. case counts). You can accept the default names for these new columns, or you can specify your own to `names_to =` and `values_to =` respectively.

Try to use `pivot_longer()` to malaria cases across the different age categories and the total count to make the data longer.

```{r standard-pivoting, exercise=TRUE, exercise.eval=TRUE, exercise.lines = 10}
df_long <- malaria_counts
```

```{r standard-pivoting-hint}
df_long <- malaria_counts %>% 
  pivot_longer(
    cols = c(`malaria_rdt_0-4`, `malaria_rdt_5-14`, `malaria_rdt_15`, `malaria_tot`)
  )

df_long
```

Notice that the newly created data frame (`df_long`) has more rows (12,152 vs 3,038); it has become *longer.* In fact, it is precisely four times as long, because each row in the original dataset now represents four rows in df_long, one for each of the malaria count observations (<4y, 5-14y, 15y+, and total).

In addition to becoming longer, the new dataset has fewer columns (8 vs 10), as the data previously stored in four columns (those beginning with the prefix `malaria_`) is now stored in two.

### **Other ways to use `pivot_longer()`**
Since the names of these four columns all begin with the prefix `malaria_`, we could have made use of the handy “tidyselect” function `starts_with()` to achieve the same result (see the page (Cleaning data and core functions)[https://www.epirhandbook.com/en/cleaning-data-and-core-functions.html] for more of these helper functions).

```{r,echo=T}
# provide column with a tidyselect helper function
malaria_counts %>% 
  pivot_longer(
    cols = starts_with("malaria_")
  )
```



We could have also selected the columns by their position:
  
  ```{r,echo=T, results='hide'}
# provide columns by position
malaria_counts %>% 
  pivot_longer(
    cols = 6:9
  )
```



As the columns follow one another, we could have also specified the first and last columns, letting R know that it should include all the columns between these with a colon `:` (as we did with the column positions above):
  
  ```{r,echo=T, results='hide'}
# provide range of consecutive columns
malaria_counts %>% 
  pivot_longer(
    cols = `malaria_rdt_0-4`:malaria_tot
  )
```



These two new columns are given the default names of `name` and `value`, but we can override these defaults to provide more meaningful names, which can help remember what is stored within, using the `names_to` and `values_to` arguments. Try to do so yourself. What would be appropriate names for these?
  
  ```{r df-long-colnames, exercise=TRUE, exercise.eval=TRUE,exercise.lines=10}
df_long <- 
  malaria_counts %>% 
  pivot_longer(
    cols = starts_with("malaria_")
  )
```

```{r df-long-colnames-hint}
df_long <- 
  malaria_counts %>% 
  pivot_longer(
    cols = starts_with("malaria_"),
    names_to = "age_group",
    values_to = "counts"
  )

df_long
```


### **Plotting age groups with the long dataset**
We can now pass this new dataset to ggplot2, and map the new column `count` to the y-axis and new column `age_group` to the `fill =` argument (the column internal color). This will display the malaria counts in a stacked bar chart, by age group:
  
  ```{r,echo=F}
df_long <- 
  malaria_counts %>% 
  pivot_longer(
    cols = starts_with("malaria_"),
    names_to = "age_group",
    values_to = "counts"
  )
```

```{r,echo=T}
ggplot(data = df_long) +
  geom_col(
    mapping = aes(x = data_date, y = counts, fill = age_group),
    width = 1
  )
```

Examine this new plot, and compare it with the plot we created earlier - *what has gone wrong*?
  
  We have encountered a common problem when wrangling surveillance data - we have also included the total counts from the `malaria_tot` column, so the magnitude of each bar in the plot is twice as high as it should be.

We can handle this in a number of ways. We could simply filter these totals from the dataset before we pass it to `ggplot()`:
  
  ```{r, echo=T}
df_long %>% 
  filter(age_group != "malaria_tot") %>% 
  ggplot() +
  geom_col(
    aes(x = data_date, y = counts, fill = age_group),
    width = 1
  )
```

Alternatively, we could have excluded this variable when we ran pivot_longer(), thereby maintaining it in the dataset as a separate variable. See how its values “expand” to fill the new rows.

```{r,echo=T}
malaria_counts %>% 
  pivot_longer(
    cols = `malaria_rdt_0-4`:malaria_rdt_15,   # does not include the totals column
    names_to = "age_group",
    values_to = "counts"
  )
```

```{r quiz-pivot_longer}
quiz(
  question("Which of the ways shown in selecting columns would not have worked when only trying to select cases by age ranges and not total cases?",
           answer("Listing column names"),
           answer("Provide column with tidyselect helper function `starts_with()`", correct = TRUE),
           answer("Column position"),
           answer("Range of consecutive columns")
  ))
```

### *Answer*
The **tidyselect** helper function `starts_with()` would not have worked here as the columns with the age range specified and the total cases column start with the same string. This is something to think about when inputting data and naming columns!