---
title: "Data cleaning"
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
description: >
  Learn how to get started with R and RStudio, and how to import a dataset
---

<!-- Add JavaScript code for making the exercise code larger -->
<script language="JavaScript" src="js/exercise-font-size.js"></script>

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 
# load packages ----------------------------------------------------------------
library(learnr)
library(gradethis)
library(tidyverse)
library(here)
library(janitor)
library(rio)
library(basket) # not sure if we need this
library(etude) # helper functions for gradethis
library(epikit)
library(linelist)
library(lubridate)
library(fastLink)
library(gtsummary)
library(rstatix)
library(corrr)

# set options for exercises and checking ---------------------------------------
gradethis_setup()

learnr::tutorial_options(exercise.timelimit = 60) 
  #exercise.checker = gradethis::grade_learnr) 
    # alternatively, submitr::null_code_checker


# event recorder ---------------------------------------------------------------
# see https://github.com/dtkaplan/submitr/blob/master/R/make_a_recorder.R
tutorial_options(exercise.eval = FALSE)  # pre-evaluate exercises

vfun <- submitr::make_basic_validator(NULL, "hello") #basket::check_valid

new_recorder <- function(tutorial_id, tutorial_version, user_id, event, data) {
    cat(
      tutorial_id, 
      " (v", tutorial_version, "); ",
      format(Sys.time(), "%Y-%M%-%D %H:%M:%S %Z"), "; ",
      user_id, "; ",
      event, "; ",
      data$label, "; ",
      data$answers, "; ",
      data$code, "; ",
      data$correct, "\n", sep = "",
      
      file = here::here("event_records", "learnr_basics.txt"),
      append = TRUE)
}

options(tutorial.event_recorder = new_recorder)


# hide non-exercise code chunks ------------------------------------------------
knitr::opts_chunk$set(echo = FALSE)


# data prep --------------------------------------------------------------------
linelist_raw <- rio::import(here::here("data", "linelist_raw.xlsx"))
linelist <- rio::import(here::here("data", "linelist_cleaned.rds"))
malaria_counts <- rio::import(here::here("data", "malaria_facility_count_data.rds"))

#Incorrectly assign class so we can clean later
linelist_raw$age <- as.character(linelist_raw$age)
linelist_raw$`date onset` <- as.character(linelist_raw$`date onset`)

#Going to randomly convert some temperatures to Fahrenheit instead of celcius for an exercise later
set.seed(1)
take_these <- sample(1:nrow(linelist_raw), 500)

linelist_raw$temp[take_these] <- (linelist_raw$temp[take_these] * 9/5) + 32

#Create some dummy df's for pivoting exercises
df <- data.frame(id = c("A", "B", "C"),
           obs1_date = c("2021-04-23", "2021-04-23", "2021-04-23"),
           obs1_status = c("Healthy", "Healthy", "Missing"),
           obs2_date = c("2021-04-24", "2021-04-24", "2021-04-24"),
           obs2_status = c("Healthy", "Healthy", "Healthy"),
           obs3_date = c("2021-04-25", "2021-04-25", "2021-04-25"),
           obs3_status = c("Unwell", "Healthy", "Healthy"))

fever_followup <- data.frame(patient = 1:10,
                             observation1_date = Sys.Date() - 21,
                        observation2_date = Sys.Date() - 14,
                        observation3_date = Sys.Date() - 7,
                        observation1_temp = sample(seq(35, 45, by = 0.1), 10, replace = T),
                        observation2_temp = sample(seq(35, 45, by = 0.1), 10, replace = T),
                        observation3_temp = sample(seq(35, 45, by = 0.1), 10, replace = T))

fever_followup$observation1_fever <- ifelse(fever_followup$observation1_date < 38, "No fever",
                              ifelse(fever_followup$observation1_date >= 38 & fever_followup$observation1_date< 39.4, "Mild fever",
                                     ifelse(fever_followup$observation1_date >= 39.4, "High fever", NA)))
fever_followup$observation2_fever <- ifelse(fever_followup$observation2_date < 38, "No fever",
                              ifelse(fever_followup$observation2_date >= 38 & fever_followup$observation2_date< 39.4, "Mild fever",
                                     ifelse(fever_followup$observation2_date >= 39.4, "High fever", NA)))
fever_followup$observation3_fever <- ifelse(fever_followup$observation3_date < 38, "No fever",
                              ifelse(fever_followup$observation3_date >= 38 & fever_followup$observation3_date< 39.4, "Mild fever",
                                     ifelse(fever_followup$observation3_date >= 39.4, "High fever", NA)))


fill_table_1 <- 
  tibble::tribble(
       ~Measurement, ~Facility, ~Cases,
                  1,  "Hosp 1",     66,
                  2,  "Hosp 1",     26,
                  3,  "Hosp 1",      8,
                  1,  "Hosp 2",     71,
                  2,  "Hosp 2",     62,
                  3,  "Hosp 2",     70,
                  1,  "Hosp 3",     47,
                  2,  "Hosp 3",     70,
                  3,  "Hosp 3",     38,
       )

fill_table_2 <- 
  tibble::tribble(
    ~Year, ~Measurement, ~Facility, ~Cases,
     2000,            1,  "Hosp 4",     82,
     2001,            2,  "Hosp 4",     87,
     2002,            3,  "Hosp 4",     46
  )

linelist_mini <- linelist %>%                 # start with original linelist
  select(case_id, date_onset, hospital) %>%   # select columns
  head(10)     

# Make the hospital information dataframe
hosp_info = data.frame(
  hosp_name     = c("central hospital", "military", "military", "port", "St. Mark's", "ignace", "sisters"),
  catchment_pop = c(1950280, 40500, 10000, 50280, 12000, 5000, 4200),
  level         = c("Tertiary", "Secondary", "Primary", "Secondary", "Secondary", "Primary", "Primary")
)

#Make some ID's and dataframes to join for exercises
patient_ID <- apply(sapply(1:10, function(x) sample(c(LETTERS, 0:9), 10, replace = T)), 2, paste0, collapse = "")


patient_symptoms <- data.frame(patient_id = sample(patient_ID, 10),
                linelist %>%
    select(fever:vomit) %>%
    filter(row_number() %in% 1:10))

patient_dates <- data.frame(id = patient_ID,
                linelist %>%
    select(contains("date")) %>%
    filter(row_number() %in% c(sample(which(is.na(linelist$date_onset)), 5),
  sample(which(!is.na(linelist$date_onset)), 5))))

#Probablistic matching

# make datasets

cases <- tribble(
  ~gender, ~first,      ~middle,     ~last,        ~yr,   ~mon, ~day, ~district,
  "M",     "Amir",      NA,          "Khan",       1989,  11,   22,   "River",
  "M",     "Anthony",   "B.",        "Smith",      1970, 09, 19,      "River", 
  "F",     "Marialisa", "Contreras", "Rodrigues",  1972, 04, 15,      "River",
  "F",     "Elizabeth", "Casteel",   "Chase",      1954, 03, 03,      "City",
  "M",     "Jose",      "Sanchez",   "Lopez",      1996, 01, 06,      "City",
  "F",     "Cassidy",   "Jones",      "Davis",     1980, 07, 20,      "City",
  "M",     "Michael",   "Murphy",     "O'Calaghan",1969, 04, 12,      "Rural", 
  "M",     "Oliver",    "Laurent",    "De Bordow" , 1971, 02, 04,     "River",
  "F",      "Blessing",  NA,          "Adebayo",   1955,  02, 14,     "Rural"
)

results <- tribble(
  ~gender,  ~first,     ~middle,     ~last,          ~yr, ~mon, ~day, ~district, ~result,
  "M",      "Amir",     NA,          "Khan",         1989, 11,   22,  "River", "positive",
  "M",      "Tony",   "B",         "Smith",          1970, 09,   19,  "River", "positive",
  "F",      "Maria",    "Contreras", "Rodriguez",    1972, 04,   15,  "Cty",   "negative",
  "F",      "Betty",    "Castel",   "Chase",        1954,  03,   30,  "City",  "positive",
  "F",      "Andrea",   NA,          "Kumaraswamy",  2001, 01,   05,  "Rural", "positive",      
  "F",      "Caroline", NA,          "Wang",         1988, 12,   11,  "Rural", "negative",
  "F",      "Trang",    NA,          "Nguyen",       1981, 06,   10,  "Rural", "positive",
  "M",      "Olivier" , "Laurent",   "De Bordeaux",  NA,   NA,   NA,  "River", "positive",
  "M",      "Mike",     "Murphy",    "O'Callaghan",  1969, 04,   12,  "Rural", "negative",
  "F",      "Cassidy",  "Jones",     "Davis",        1980, 07,   02,  "City",  "positive",
  "M",      "Mohammad", NA,          "Ali",          1942, 01,   17,  "City",  "negative",
  NA,       "Jose",     "Sanchez",   "Lopez",        1995, 01,   06,  "City",  "negative",
  "M",      "Abubakar", NA,          "Abullahi",     1960, 01,   01,  "River", "positive",
  "F",      "Maria",    "Salinas",   "Contreras",    1955, 03,   03,  "River", "positive"
  )


cases_dup <- rbind(cases,
                   data.frame(
                     gender = c("M", "F"),
           first = c("Tony", "Maria"),
           middle = c("B.", "Contreras"),
           last = c("Smith", "Rodriguez"),
           yr = c(1970, 1972),
           mon = c(9, 4),
           day = c(19, 15),
           district = c("River", "River"))
           )

#Create a  factor column
linelist$source[is.na(linelist$source)] <- "missing"
linelist$source <- factor(linelist$source)

```


```{r}
submitr::login_controls() # show login and password with "Submit" button.
```


```{r context = "server", echo = FALSE}
# see https://rdrr.io/github/dtkaplan/submitr/f/vignettes/using.Rmd
options(tutorial.storage = "none")
vfun <- submitr::make_basic_validator(NULL, "hello")       #basket::check_valid
storage_actions <- submitr::record_local("./minimal_submissions.csv")
submitr::shiny_logic(input, output, session, vfun,
                     storage_actions)
```




## Introduction to R for Applied Epidemiology and Public Health
### Data cleaning and core functions

```{r appliedepi-banner, fig.margin = TRUE, echo = FALSE, fig.width = 3, out.width = "100%", fig.cap = ""}
knitr::include_graphics("images/moz-banner.png")
```


### Welcome

Welcome to the course "Introduction to R for applied epidemiologists", offered for free by [Applied Epi](www.appliedepi.org) - a non-profit organisation that offers open-source tools, training, and support to frontline public health practitioners.

This interactive tutorial focuses on **cleaning of datasets often encountered by applied epidemiologists and public health practitioners**, such as outbreak linelists, surveillance, and laboratory data.  


#### Target Audience  

This course is designed with the following objectives: 

* To be friendly to people who have never used a programming language before
* To teach R emphasizing examples, datasets, and challenges commonly faced by applied epidemiologists
* To be modular - so that you can skip to section most relevant to you

If this is your first introduction to R programming, please consider first completing our [R Setup and Data Import tutorial], which introduces R, RStudio, R projects, R code syntax, and explains how to import a dataset into R.  



#### Other languages
This course is available...


#### Offline / Online

You can access this tutorial offline by downloading our R package ... 
If viewing offline, you can view the videos by doing ...



#### Learning goals

In this tutorial you will learn and practice:  

* Using the pipe operator (`%>%`) to pass the dataset from one cleaning function to another
* The core **tidyverse** R functions used to reduce, clean, and modify dataframes  
* How to manipulate dates in order to clean and translate between units of time (days/months/years) with the **lubridate** package
* The use of descriptive analysis and summary statistics with the **janitor** package in order to summarize your data



This tutorial adapts the [Data cleaning and core functions](https://epirhandbook.com/en/cleaning-data-and-core-functions.html) section of our free [ Epidemiologist R Handbook](https://epirhandbook.com/en/), which is available for use offline as well. 


#### Data consent

We continually improve these tutorials by collecting your entries and submitted answers to the quiz questions. By continuing, you consent to this collection and use.

To continue anonymously... do XYZ.



#### Who made this course  

This course is designed by epidemiologists with decades of ground-level experience in outbreak response and local public health work. 


```{r appliedepi-hexes, fig.margin = TRUE, echo = FALSE, fig.width = 3, out.width = "50%", fig.cap = ""}
knitr::include_graphics("images/hex-sidebyside.png")
```


## Data used and directory structure

In this tutorial we will use the following datasets. Please take a few minutes to review the structure and content of each dataset before continuing.

Use the arrows on the right to scroll through hidden columns. Note that these are "raw" (messy) datasets that mimic problems commonly found in real-life epidemiological datasets.  


### **A "linelist" of cases in a fictional (not real) Ebola outbreak**

A "linelist" is a term used in applied epidemiology to refer to a table that contains key information about each case or suspect case in an outbreak. Each row represents one case, and the columns contain variables such as age, sex, date of symptom onset, outcomes, etc.

This dataset contains `r nrow(linelist_raw)` rows and `r ncol(linelist_raw)` columns. Below are the first 5 rows:  

```{r}
head(linelist_raw)
```

Click to [download the **raw** dataset](https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_raw.xlsx) for your own practice.

Click to [download the **clean** dataset as an **.rds file**](https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds) for your own practice. A *.rds file* is an R-specific file type that preserves column classes. This ensures you will have only minimal cleaning to do after importing the data into R.

### **Aggregated data from malaria surveillance in a fictional country**  

Aggregated data in epidemiology usually means a table of counts for each facility, or district, etc. Sometimes, the counts can also be per day, week, or month.  

In this fictional dataset, each facility reported *daily* case counts of rapid-test (RDT)-confirmed malaria. Thus, each row represents the number of cases for a specific facility on a specific day.  

This dataset contains `r nrow(malaria_counts)` rows and `r ncol(malaria_counts)` columns. Below are the first 5 rows:  

```{r}
head(malaria_counts)
```


Click to [download the **clean** malaria counts dataset as an **.rds file**](https://github.com/appliedepi/epirhandbook_eng/raw/master/data/malaria_facility_count_data.rds) for your own practice. A *.rds file* is an R-specific file type that preserves column classes. This ensures you will have only minimal cleaning to do after importing the data into R.


### Directory structure

Photo or GIF of directory structure

### Accessing example data
Here is how to access the example data

### Tidy Data

We highly recommend doing our tutorial on Tidy Data in Applied Epidemiology. Collecting, formatting, and preparing your dataset *before* importing it into R is a critical step!
LINK
VIDEO TEASER




## Install and Load R packages {#packages}

To use basic functions with public health data, the tidyverse metapackage is very useful. Tidyverse loads the dplyr, ggplot2, and other packages that are useful in epi data analysis. 

We've preloaded the below packages for now. Installation and loading of these packages is described on the EpiRHandbook [_Suggested Packages_](https://epirhandbook.com/en/suggested-packages-1.html) page. 


In this assignment we'll work with X R packages, let's load them!

```{r load-package, exercise = TRUE}
pacman::p_load(___)
```

```{r load-package-hint}
pacman::p_load(rio, here, janitor, tidyverse)

```

```{r load-package-check}
grade_this_code("You are correct, the packages you need for this lesson are now loaded!")
```

```{r eval=FALSE}
pacman::p_load(learnr, here, rio, janitor, tidyverse)
```

### Recommended R packages for public health

See this Epi R Handbook LINK for our recommended packages.


## Import data {#import} 
https://www.epirhandbook.com/en/import-and-export.html
Import that data and save it as "raw" file

To import data from a sub-folder, the `import()` command should be modified so that it correctly tells R where to search for this file. This is done using the here() function. 

```{r import-demo-subfolder, echo=T, eval=F}
linelist_raw <- import(here("data", "linelist_raw.xlsx"))   # import data and save as named object
```

## Descriptive tables

Once you have a clean dataset, you may want to conduct some basic statistical analysis and summaries in order to better understand your data.

There are a number of different packages that can be used to do this such as **janitor**, **dplyr**, **gtsummary**, **rstatix** and **base** R in order to summarize and create tables with descriptive statistics.

Each of these have their own advantages and disadvantages, and the tool you use will depend on factors such as code simplicity, customizeability and the desired output (printed to R console or a figure for a report/publication). Consider the points below:

* Use `tably()` from **janitor** to produce and "adorn" tabulations and cross-tabulations
* Use `get_summary_stats()` from **rstatix** to easily generate dataframes of numerical summary statistics from multiple columns or groups
* Use `summarize()` and `count()` from **dplyr** for more complex statistics, tidy dataframe outputs or preparing data for `ggplot()`
* Use `tbl_summary()` from **gtsummary** to produce detailed publication-ready tables
* Use `table()` from **base** R if you do not have access to the above packages

### **janitor**

The **janitor** package offers the `tabyl()` function to produce tabulations and cross-tabulations, which can be "adorned" or modified with helper functions to display percentages, proportions, counts, etc.

Below we summarize the column `age_cat`:

```{r, echo = T, eval = T}
linelist %>%
  tabyl(age_cat)

```

You can adjust the number of decimals with `adorn_round()`, and if you want to ignore `NA` values you can suppress them by including `show_na = FALSE`.

```{r, echo = T, eval = T}
linelist %>%
  tabyl(age_cat, show_na = FALSE) %>%
  adorn_rounding(digits = 3) #Specify the number of digits with the digits = argument
```

If the column is class Factor and only certain levels are present in your data, all levels will still appear in the table. You can suppress this feature by specifying `show_missing_levels = FALSE`:

```{r, echo = T, eval = T}
linelist %>%
  filter(source != "other") %>%
  tabyl(source)

linelist %>%
  filter(source != "other") %>%
  tabyl(source, show_missing_levels = FALSE)

```

## Cross-tabulation

Cross-tabulation counts are achieved by adding one or more additional columns within 1. Note that now only counts are returned - proportions and percents can be added with additional steps shown below.

```{r, echo = T, eval = T}
linelist %>% 
  tabyl(age_cat, gender)
```

### Adoring the tabyl

Use **janitor**’s “adorn” functions to add totals or convert to proportions, percents, or otherwise adjust the display. Often, you will pipe the tabyl through several of these functions.

| **Function**      | **Outcome** |
| ----------- | ----------- |
| `adorn_totals()`      | Adds totals (`where = ` "row", "column", "both"). Set `name = ` for "Total"       |
| `adorn_percentages()`   | Convert counts to proportions, with `denominator = ` "row", "col" or "all"        |
| `adorn_pct_formatting()`   | Converts proportions to percents. Specify `digits =`. Remove the “%” symbol with `affix_sign = FALSE`        |
| `adorn_rounding()`   | To round proportions to `digits =` places. To round percents use `adorn_pct_formatting()` with `digits =`        |
| `adorn_ns()`   | Add counts to a table of proportions or percents. Indicate `position = “rear”` to show counts in parentheses, or “front” to put the percents in parentheses|
| `adorn_title()`   | Add counts to a table of proportions or percents. Indicate `position = “rear”` to show counts in parentheses, or “front” to put the percents in parentheses|

Can you summarize age categories in `linelist`, drop `NA` values, and "adorn" them to show the percentage to 2 decimal places?

```{r crosstab_age, exercise = TRUE}
  
```

```{r crosstab_age-hint}
Re-read the table above if you need help deciding which "adorn" function to use in order to display age categories as a percentage
```

```{r crosstab_age-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal()
    # Default to failing grade with feedback
    fail(message = "Remember to drop NA values using 'show_na = FALSE'")
  })
```

```{r crosstab_age-solution}
linelist %>%
    tabyl(age_cat, show_na = FALSE) %>%
    adorn_pct_formatting(digits = 2)
```

Now we want to create a cross table of `age_cat` and `gender`, where we work out the percentage in each gender by row, and the overall percentage in each gender across all age categories. Can you use several "adorn" functions to do this?

```{r crosstab_age_gender, exercise = TRUE}
  
```

```{r crosstab_age_gender-hint}
You will need to use three "adorn" functions. Remember to specify "where = " for totals, and the "denominator = " correctly.
```

```{r crosstab_age_gender-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal()
    # Default to failing grade with feedback
    fail()
  })
```

```{r crosstab_age_gender-solution}
linelist %>%                                  
  tabyl(age_cat, gender) %>%
  adorn_totals(where = "row") %>%
  adorn_percentages(denominator = "row") %>%
  adorn_pct_formatting()
```

```{r quiz11}
quiz(
  question("Which of these would change the row name title to 'Age category' and add a title to the groups (gender) of 'Gender'?",
           answer("adorn_totals(row_name = 'Age Category', col_name = 'Gender')", correct = F),
           answer("tabyl(row_name = 'Age Category', col_name = 'Gender')", correct = F),
           answer("adorn_title(row_name = 'Age Category', col_name = 'Gender')", correct = T))
  )
```

### Printing the tabyl

By default, the tabyl will print raw to your R table.

Alternatively, you can pass the tabyl to **flextable** or similar package to print as a “pretty” image in the RStudio Viewer, which could be exported as .png, .jpeg, .html, etc. Note that if printing in this manner and using `adorn_titles()`, you must specify `placement = "combined"`.

```{r, echo = T, eval = T}
linelist %>%
  tabyl(age_cat, gender) %>% 
  adorn_totals(where = "col") %>% 
  adorn_percentages(denominator = "col") %>% 
  adorn_pct_formatting() %>% 
  adorn_ns(position = "front") %>% 
  adorn_title(
    row_name = "Age Category",
    col_name = "Gender",
    placement = "combined") %>% # this is necessary to print as image
  flextable::flextable() %>%    # convert to pretty image
  flextable::autofit()          # format to one line per row 
```

### Use on other tables

You can use janitor’s adorn_*() functions on other tables, such as those created by summarise() and count() from dplyr, or table() from base R. Simply pipe the table to the desired janitor function. For example:

```{r, echo = T, eval = T}
linelist %>% 
  count(hospital) %>%   # dplyr function
  adorn_totals()        # janitor function
```

### Saving the tabyl

If you convert the table to a “pretty” image with a package like **flextable**, you can save it with functions from that package - like `save_as_html()`, `save_as_word()`, `save_as_ppt()`, and `save_as_image()` from **flextable**

```{r, echo = T, eval = F}
linelist %>%
  tabyl(age_cat, gender) %>% 
  adorn_totals(where = "col") %>% 
  adorn_percentages(denominator = "col") %>% 
  adorn_pct_formatting() %>% 
  adorn_ns(position = "front") %>% 
  adorn_title(
    row_name = "Age Category",
    col_name = "Gender",
    placement = "combined") %>% 
  flextable::flextable() %>%                     # convert to image
  flextable::autofit() %>%                       # ensure only one line per row
  flextable::save_as_docx(path = "tabyl.docx")   # save as Word document to filepath
```

### Statistics

You can apply statistical tests on tabyls, like `chisq.test()` or `fisher.test()` from the **stats** package as shown below. Note missing values are not allowed so they are excluded from the tabyl with `show_na = FALSE`.

```{r, echo = T, eval = T}
age_by_outcome <- linelist %>% 
  tabyl(age_cat, outcome, show_na = FALSE) 

chisq.test(age_by_outcome)
```

We will look further into statistical tests later on in this exericse.

## **dplyr** package

**dplyr** is part of the tidyverse packages and is an very common data management tool. Creating tables with **dplyr** functions `summarise()` and `count()` is a useful approach to calculating summary statistics, summarize by group, or pass tables to `ggplot()`.

`summarise()` creates a new, summary data frame. If the data are ungrouped, it will return a one-row dataframe with the specified summary statistics of the entire data frame. If the data are grouped, the new data frame will have one row per group (see Grouping data page).

Within the `summarise()` parentheses, you provide the names of each new summary column followed by an equals sign and a statistical function to apply.

*Get counts*

The most simple function to apply within `summarise()` is `n()`. Leave the parentheses empty to count the number of rows.
```{r, echo = T, eval = T}
linelist %>% 
  summarise(n_rows = n())   # return number of rows 
```

This gets more interesting if we have grouped the data beforehand.

```{r, echo = T, eval = T}
linelist %>% 
  group_by(age_cat) %>%     # group data by unique values in column age_cat
  summarise(n_rows = n())   # return number of rows *per group*
```

The above command can be shortened by using the count() function instead. count() does the following:

1. Groups the data by the columns provided
2. Summarises them with `n()`, creating the column `n`
3. Un-groups the data

```{r, echo = T, eval = T}
linelist %>% 
  count(age_cat)
```

You can change the name of the counts column from the default `n` to something else by specifying it to `name =`.

Tabulating counts of two or more grouping columns are still returned in “long” format, with the counts in the n column. See the page on Pivoting data to learn about “long” and “wide” data formats.

```{r, echo = T, eval = T}
linelist %>% 
  count(age_cat, outcome)
```

If you are tabling a column of class _factor_ then you can ensure _all_ levels are shown by adding `.drop = FALSE` into `summarise()` or `count()`. 

Can you create a cross table of `gender` and `source`?

```{r gender_count, exercise = TRUE}
  
```

```{r crosstab_age_gender-hint}
```

```{r gender_count-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal()
    # Default to failing grade with feedback
    fail()
  })
```

```{r gender_count-solution}
linelist %>% 
  count(gender, source)
```

### Proportions

Proportions can be added by piping the table to `mutate()` to create a new column. Define the new column as the counts column (n by default) divided by the `sum()` of the counts column (this will return a proportion).

Note that in this case, `sum()` in the `mutate()` command will return the sum of the whole column n for use as the proportion denominator. If `sum()` is used in grouped data (e.g. if the `mutate()` immediately followed a `group_by()` command), it will return sums by group. As stated just above, `count()` finishes its actions by ungrouping. Thus, in this scenario we get full column proportions.

To easily display percents, you can wrap the proportion in the function `percent()` from the package **scales** (note this convert to class character).

```{r, echo = T, eval = T}
age_summary <- linelist %>% 
  count(age_cat) %>%                     # group and count by gender (produces "n" column)
  mutate(                                # create percent of column - note the denominator
    percent = scales::percent(n / sum(n))) 

# print
age_summary
```

If you wish to calculate proportions _within groups_ then you need to additionally group the data using `group_by()`:

```{r, echo = T, eval = T}
age_by_outcome <- linelist %>%                  # begin with linelist
  group_by(outcome) %>%                         # group by outcome 
  count(age_cat) %>%                            # group and count by age_cat, and then remove age_cat grouping
  mutate(percent = scales::percent(n / sum(n))) # calculate percent - note the denominator is by outcome group
```

Can you now drop the `NA` values from `gender` and `outcome` in `linelist`, then produce a cross-table of `gender` and `outcome` to count the number of rows in each cross-tabulation?

```{r dplyr_crosstab, exercise = TRUE}
linelist %>%
  
```

```{r dplyr_crosstab-hint}
You can remove NA values using a number of different commands, but remember that we only care about the NA values in the columns 'gender' and 'outcome'. Additionally, remember how many columns we need to group by.
```

```{r dplyr_crosstab-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal()
    # Default to failing grade with feedback
    fail()
  })
```

```{r dplyr_crosstab-solution}
linelist %>% 
    drop_na(gender, outcome) %>%
    group_by(gender, outcome) %>%
    count()
```

### Plotting

One of the advantages of using **dplyr** is that the data is already in the format expected for plotting by **ggplot**, for example:

```{r, echo = T, eval = T}
linelist %>%                      # begin with linelist
  count(age_cat, outcome) %>%     # group and tabulate counts by two columns
  ggplot()+                       # pass new data frame to ggplot
    geom_col(                     # create bar plot
      mapping = aes(   
        x = outcome,              # map outcome to x-axis
        fill = age_cat,           # map age_cat to the fill
        y = n))                   # map the counts column `n` to the height
```

### Summary statistics

Another advantage of using **dplyr** and `summarise()` is that you can return more advanced statistical summarises such as `median()`, `mean()`, `max()`, `min()`, `sd()` (standard deviation) and percentiles. 

The syntax is the same - within the `summarise()` parentheses you provide the names of each new summary column followed by an equals sign and a statistical function to apply. Within the statistical function, give the column(s) to be operated on and any relevant arguments (e.g. `na.rm = TRUE` for most mathematical functions).

You can also use `sum()` to return the number of rows that meet a logical criteria. The expression within is counted if it evaluates to `TRUE`. For example:

* `sum(age_years < 18, na.rm = T)`
* `sum(gender == "male", na.rm = T)`
* `sum(response %in% c("Likely", "Very Likely"))`

Below, `linelist` data are summarised to describe the days delay from symptom onset to hospital admission (column `days_onset_hosp`), by hospital.

```{r, echo = T, eval = T}
summary_table <- linelist %>%                                        # begin with linelist, save out as new object
  group_by(hospital) %>%                                             # group all calculations by hospital
  summarise(                                                         # only the below summary columns will be returned
    cases       = n(),                                                # number of rows per group
    delay_max   = max(days_onset_hosp, na.rm = T),                    # max delay
    delay_mean  = round(mean(days_onset_hosp, na.rm = T), digits = 1),  # mean delay, rounded
    delay_sd    = round(sd(days_onset_hosp, na.rm = T), digits = 1),  # standard deviation of delays, rounded
    delay_3     = sum(days_onset_hosp >= 3, na.rm = T),               # number of rows with delay of 3 or more days
    pct_delay_3 = scales::percent(delay_3 / cases)                    # convert previously-defined delay column to percent 
  )

summary_table  # print
```

Can you now summarise the median, min and max ages in `age` by `gender` in `linelist`? Remember to remove `NA` values!

```{r dplyr_summarise, exercise = TRUE}
linelist %>%
  
```

```{r dplyr_summarise-hint}
Remember to drop NA values from 'gender' and to ignore NA values in the age column.
```

```{r dplyr_summarise-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal()
    # Default to failing grade with feedback
    fail()
  })
```

```{r dplyr_summarise-solution}
linelist %>%
    group_by(gender) %>%
    drop_na(gender) %>%
    summarise(
    median_age = median(age, na.rm = T),
    min_age = min(age, na.rm = T),
    max_age = max(age, na.rm = T),
)
```

### Conditional statistics

We may want to return _conditional statistics_, e.g. the maximum of rows that meet a certain criteria. This can be done by subsetting the column with a square bracket `[]`. The example below returns the maximum temperature for patients classified having or not having fever. Be aware however - it may be more appropriate to add another column to the `group_by()` command and `pivot_wider()`.

```{r, echo = T, eval = T}
linelist %>% 
  group_by(hospital) %>% 
  summarise(
    max_temp_fvr = max(temp[fever == "yes"], na.rm = T),
    max_temp_no = max(temp[fever == "no"], na.rm = T)
  )
```

Can you now work out the proportion of people (in a column `prop_outcome_death`) who have the outcome of death by age category and gender?

```{r dplyr_conditional_death, exercise = TRUE}
linelist %>%
  
```

```{r dplyr_conditional_death-hint}
You may have to use group_by() more than once, and count() as well as summarise()
```

```{r dplyr_conditional_death-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal()
    # Default to failing grade with feedback
    fail()
  })
```

```{r dplyr_conditional_death-solution}
linelist %>% 
  group_by(age_cat, outcome) %>% 
  count(outcome) %>%
  group_by(age_cat) %>%
  summarise(prop_outcome_death = sum(n[outcome == "Death"], na.rm = T)/sum(n, na.rm = T))
```

### Glueing together

The function `str_glue()` from **stringr** is useful to combine values from several columns into one new column. In this context this is typically used after the `summarise()` command.

In the Characters and strings page, various options for combining columns are discussed, including `unite()`, and `paste0()`. In this use case, we advocate for `str_glue()` because it is more flexible than `unite()` and has more simple syntax than `paste0()`.


Below, the `summary_table` data frame (created above) is mutated such that columns `delay_mean` and `delay_sd` are combined, parentheses formating is added to the new column, and their respective old columns are removed.

Then, to make the table more presentable, a total row is added with `adorn_totals()` from janitor (which ignores non-numeric columns). Lastly, we use `select()` from **dplyr** to both re-order and rename to nicer column names.

```{r, echo = T, eval = T}
summary_table %>% 
  mutate(delay = str_glue("{delay_mean} ({delay_sd})")) %>%  # combine and format other values
  select(-c(delay_mean, delay_sd)) %>%                       # remove two old columns   
  adorn_totals(where = "row") %>%                            # add total row
  select(                                                    # order and rename cols
    "Hospital Name"   = hospital,
    "Cases"           = cases,
    "Max delay"       = delay_max,
    "Mean (sd)"       = delay,
    "Delay 3+ days"   = delay_3,
    "% delay 3+ days" = pct_delay_3
    )
```

### Percentiles

Percentiles and quantiles in **dplyr** deserve a special mention. To return quantiles, use `quantile()` with the defaults or specify the value(s) you would like with `probs =`.

```{r, echo = T, eval = T}
# get default percentile values of age (0%, 25%, 50%, 75%, 100%)
linelist %>% 
  summarise(age_percentiles = quantile(age_years, na.rm = TRUE))
```

and if we wanted to use manually specified percentiles, and show them by hospital

```{r, echo = T, eval = T}
# get manually-specified percentile values of age (5%, 50%, 75%, 98%)
linelist %>% 
  group_by(hospital) %>% 
  summarise(
    p05 = quantile(age_years, probs = 0.05, na.rm=T),
    p50 = quantile(age_years, probs = 0.5, na.rm=T),
    p75 = quantile(age_years, probs = 0.75, na.rm=T),
    p98 = quantile(age_years, probs = 0.98, na.rm=T)
    )
```

Can you use what you have learned above to do the following:

1) Remove `NA` values from `outcome` and `age_cat` and group by these columns
2) Summarise `wt_kg` to produce quantiles of 2.5%, 50% and 97.5% in columns called `p02.5`, `p50` and `p97.5`
3) Use `str_glue()` to combine the columns as "p50 (p02.5 - p97.5)" and call this new column `wt_kg_quantile". This will display the median and 95% quantile values in a single column.

```{r glue_quantile, exercise = TRUE}
linelist %>%
  
```

```{r glue_quantile-hint}
Remember to carry out the exercise in the order specified above. You have been through each of these steps individually, it is now time to combine them.
```

```{r glue_quantile-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal()
    # Default to failing grade with feedback
    fail()
  })
```

```{r glue_quantile-solution}
linelist %>%
  drop_na(outcome, age_cat) %>%
  group_by(outcome, age_cat) %>%
  summarise(p02.5 = quantile(wt_kg, probs = 0.025, na.rm = T),
            p50 = quantile(wt_kg, probs = 0.5, na.rm = T),
            p97.5 = quantile(wt_kg, probs = 0.975, na.rm = T)) %>%
  transmute(outcome,
            age_cat,
            wt_kg_quantile = str_glue("{p50} ({p02.5} - {p97.5})"))
  
```

### Summarise aggregated data

If you begin with aggregated data, using `n()` return the number of rows, not the sum of the aggregated counts. To get sums, use `sum()` on the data’s counts column.

For example, let’s say you are beginning with the data frame of counts below, called `linelist_agg` - it shows in “long” format the case counts by outcome and gender.

```{r, echo = T, eval = T}
linelist_agg <- linelist %>% 
  drop_na(gender, outcome) %>% 
  count(outcome, gender)

linelist_agg
```

To sum the counts (in column `n`) by group you can use `summarise()` but set the new column equal to `sum(n, na.rm=T)`. To add a conditional element to the sum operation, you can use the subset bracket `[ ]` syntax on the counts column.

```{r, echo = T, eval = T}
linelist_agg %>% 
  group_by(outcome) %>% 
  summarise(
    total_cases  = sum(n, na.rm=T),
    male_cases   = sum(n[gender == "m"], na.rm=T),
    female_cases = sum(n[gender == "f"], na.rm=T))
```

```{r rhetorical1, echo = FALSE}
question_text(
  "Why would you want to display summarised data by groups?",
  answer_fn(function(value) {
    if (grepl(paste(letters, collapse = "|"), value)) {
      correct("")
    }
  }, )
)
```

### `across()`

You can use `summarise()` across multiple columns using `across()`. This makes life easier when you want to calculate the same statistics for many columns. Place `across()` within `summarise()` and specify the following:

* `.cols` = as either a vector of column names `c()` or “tidyselect” helper functions
* `.fns` = the function to perform (no parentheses) - you can provide multiple within a `list()`

Below, `mean()` is applied to several numeric columns. A vector of columns are named explicitly to `.cols =` and a single function mean is specified (no parentheses) to `.fns =`. Any additional arguments for the function (e.g. `na.rm=TRUE`) are provided after `.fns =`, separated by a comma.

It can be difficult to get the order of parentheses and commas correct when using `across()`. Remember that within `across()` you must include the columns, the functions, and any extra arguments needed for the functions.

```{r, echo = T, eval = T}
linelist %>% 
  group_by(outcome) %>% 
  summarise(across(.cols = c(age_years, temp, wt_kg, ht_cm),  # columns
                   .fns = mean,                               # function
                   na.rm=T))                                  # extra arguments
```

You can also use multiple functions at once if you provide the argument to `.fns = ` within a `list()`. You can also provide character names which are appended in the new column names.

```{r, echo = T, eval = T}
linelist %>% 
  group_by(outcome) %>% 
  summarise(across(.cols = c(age_years, temp, wt_kg, ht_cm), # columns
                   .fns = list("mean" = mean, "sd" = sd),    # multiple functions 
                   na.rm=T))                                 # extra arguments
```


Here are those “tidyselect” helper functions you can provide to `.cols =` to select columns:

* `everything()` - all other columns not mentioned
* `last_col()` - the last column
* `where()` - applies a function to all columns and selects those which are `TRUE`
* `starts_with()` - matches to a specified prefix. Example: `starts_with("date")`
* `ends_with()` - matches to a specified suffix. Example: `ends_with("_end")`
* `contains()` - columns containing a character string. Example: `contains("time")`
* `matches()` - to apply a regular expression (regex). Example: `contains("[pt]al")`
* `num_range()` -
* `any_of()` - matches if column is named. Useful if the name might not exist. Example: `any_of(date_onset, date_death, cardiac_arrest)`


```{r quiz12}
quiz(
  question("Which of these would select all numeric columns and take the mean?",
           answer("across(.cols = where(is.numeric), .fns = list('mean' = mean), na.rm = T)", correct = T),
           answer("across(.cols = contains(numeric), .fns = list('mean' = mean), na.rm = T)", correct = F),
           answer("across(.cols = matches('numeric'), .fns = list('mean' = mean))", correct = F)),
   question("Which of these would select all column names that contain 'date' and get the standard deviation and max value?",
           answer("across(.cols = where(is.Date), .fns = list('mean' = mean), na.rm = T)", correct = F),
           answer("across(.cols = contains('date'), .fns = list('mean' = mean, 'sd' = sd), na.rm = T)", correct = T),
           answer("across(.cols = matches('date'), .fns = c('mean' = mean, 'sd' = sd))", correct = F)),
  question("Which of these would select all column names that contain 'years' and get the min value?",
           answer("across(.cols = contains('years'), .fns = list('min' = min), na.rm = T)", correct = T),
           answer("across(.cols = matches('years'), .fns = list('min' = min), na.rm = T)", correct = T),
           answer("across(.cols = any_of('years'), .fns = list('min' = min), na.rm = T)", correct = F))
  )
```

Can you summarise `linelist` by `gender` in order to calculate the numer of deaths and recovered and then add on totals, proportions in each category (by column) and convert these to percentages?

```{r linelist_adorn, exercise = TRUE}
linelist %>%
  
```

```{r linelist_adorn-hint}
Remember you can use the "adorn_" functions from the janitor package on dplyr (and any other) tables. Refer to the previous section if you need to be reminded of which "adorn_" functions to use
```

```{r linelist_adorn-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal()
    # Default to failing grade with feedback
    fail()
  })
```

```{r linelist_adorn-solution}
linelist %>% 
  group_by(gender) %>%
  summarise(
    n_death  = sum(outcome == "Death", na.rm = T),
    n_recover = sum(outcome == "Recover", na.rm = T),
  ) %>% 
  adorn_totals() %>% 
  adorn_percentages("col") %>% 
  adorn_pct_formatting()
  
```


## **gtsummary** package

If you want to print your summary statistics in a pretty, publication-ready graphic, you can use the **gtsummary** package and its function `tbl_summary()`. The code can seem complex at first, but the outputs look very nice and print to your RStudio Viewer panel as an HTML image.

### Summary table

The default behavior of `tbl_summary()` provides a summary of the columns included, outputting median and inter-quartile range (IQR) for numeric columns, and counts (%) for categorical columns. Missing values are converted to “Unknown”. Footnotes are added to the bottom to explain the statistics, while the total N is shown at the top.

```{r, echo = T, eval = T}
linelist %>% 
  select(age_years, gender, outcome, fever, temp, hospital) %>%  # keep only the columns of interest
  tbl_summary()                                                  # default
```

This summary table gives you a good overview of the columns of interest, however you are likely to want to make some adjustments

```{r rhetorical1, echo = FALSE}
question_text(
  "How often do produce summary tables, and how long does it usually take? Could R help automate and reduce your workload?",
  answer_fn(function(value) {
    if (grepl(paste(letters, collapse = "|"), value)) {
      correct("")
    }
  }, )
)
```

### Adjustments

Now we will explain how the function works and how to make adjustments. The key arguments are detailed below:

* `by = ` -  You can stratify your table by a column (e.g. by outcome), creating a 2-way table.
* `statistic = ` - Use an equations to specify which statistics to show and how to display them. There are two sides to the equation, separated by a tilde `~`
  * The right side of the equation uses the syntax of `str_glue()` from **stringr** 
  * For the left side of the equation, you can specify columns by name (e.g. `age` or c(`age`, `gender`)) or using helpers such as `all_continuous()`, `contains()`, `starts_with()`, etc.

```{r, echo = T, eval = T}
linelist %>% 
  select(age_years) %>%                       # keep only columns of interest 
  tbl_summary(                                # create summary table
    statistic = age_years ~ "({min}, {max})") # print min and max of age
```

  * You can also differentiate syntax for separate columns or types of columns by providing them in a `list()`, e.g. 

```{r, echo = T, eval = T}
linelist %>% 
  select(age_years, gender, outcome, fever, temp, hospital) %>% # keep only columns of interest
  tbl_summary(     
    by = outcome,                                               # stratify entire table by outcome
    statistic = list(all_continuous() ~ "{mean} ({sd})",        # stats and format for continuous columns
                     all_categorical() ~ "{n} / {N} ({p}%)"),   # stats and format for categorical columns
    digits = all_continuous() ~ 1,                              # rounding for continuous columns
    type   = all_categorical() ~ "categorical",                 # force all categorical levels to display
    label  = list(                                              # display labels for column names
      outcome   ~ "Outcome",                           
      age_years ~ "Age (years)",
      gender    ~ "Gender",
      temp      ~ "Temperature",
      hospital  ~ "Hospital"),
    missing_text = "Missing"                                    # how missing values should display
  )
```

Can you now, using adjustments, produce a table which shows the summary of `age_years` and `outcome` by `gender` from `linelist`? Additionally we want to:

* Produce summary statistics that show "median (min - max)"
* Rename `age_years`, `outcome` and `gender` to `Age`, `Outcome`, `Gender`
* Rename any missing text as "Not found"

```{r adjust_age_gender_outcome, exercise = TRUE}
  
```

```{r adjust_age_gender_outcome-hint}
```

```{r gender_count-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal()
    # Default to failing grade with feedback
    fail()
  })
```

```{r adjust_age_gender_outcome-solution}
linelist %>% 
    select(age_years, gender, outcome) %>%
    tbl_summary(by = gender,
                statistic = list(all_continuous() ~ "{median} ({min} - {max})"),
                label = list(
                  outcome ~ "Outcome",
                  age_years ~ "Age",
                  gender ~ "Gender"
                ),
                missing_text = "Not found")
```

### Multi-line stats for continuous variables

If you want to print multiple lines of statistics for continuous variables, you can indicate this by setting the `type =` to "continuous2". You can combine all of the previously shown elements in one table by choosing which statistics you want to show. To do this you need to tell the function that you want to get a table back by entering the type as "continuous2". The number of missing values is shown as "Unknown".

```{r, echo = T, eval = T}
linelist %>% 
  select(age_years, temp) %>%                      # keep only columns of interest
  tbl_summary(                                     # create summary table
    type = all_continuous() ~ "continuous2",       # indicate that you want to print multiple statistics 
    statistic = all_continuous() ~ c(
      "{mean} ({sd})",                             # line 1: mean and SD
      "{median} ({p25}, {p75})",                   # line 2: median and IQR
      "{min}, {max}")                              # line 3: min and max
    )
```

Can you now produce a summary table of `outcome`, `age_cat`, `temp`, `wt_kg` where they are analysed by `gender`? For continuous values the output should be "median (min - max)" and for categorical values the percent in each category.

```{r gtsummary_first, exercise = TRUE}
linelist %>%
  
```

```{r gtsummary_first-hint}
You will need to select the specified columns, and then treat continuous and categorical values differently
```

```{r gtsummary_first-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal()
    # Default to failing grade with feedback
    fail()
  })
```

```{r gtsummary_first-solution}
linelist %>%
  select(gender, outcome, age_cat, temp, wt_kg) %>%
  tbl_summary(by = gender,
              statistic = list(all_continuous() ~ "{median} ({min} - {max})",
                               all_categorical() ~ "{n} / {N} ({p}%)"))
  
```

### **base** R

You can use the function `table()` to tabulate and cross-tabulate columns. Unlike the options above, you must specify the dataframe each time you reference a column name, as shown below.

CAUTION: `NA` (missing) values will not be tabulated unless you include the argument `useNA = "always"` (which could also be set to “no” or “ifany”).

```{r, echo = T, eval = T}
table(linelist$outcome, useNA = "always")
```

Multiple columns can be cross-tabulated by listing them one after the other, separated by commas. Optionally, you can assign each column a “name” like `Outcome = linelist$outcome`.

```{r, echo = T, eval = T}
age_by_outcome <- table(linelist$age_cat, linelist$outcome, useNA = "always") # save table as object
age_by_outcome   # print table
```

### Proportions

To return proportions, passing the above table to the function `prop.table()`. Use the margins = argument to specify whether you want the proportions to be of rows (1), of columns (2), or of the whole table (3). For clarity, we pipe the table to the round() function from **base** R, specifying 2 digits.

```{r, echo = T, eval = T}
# get proportions of table defined above, by rows, rounded
prop.table(age_by_outcome, 1) %>% round(2)
```

to add row and columns total, pass the table to `addmargins()`.

```{r, echo = T, eval = T}
# get proportions of table defined above, by rows, rounded
addmargins(age_by_outcome)
```

## Simple statistical tests

Here we will demonstrate several simple statistical tests using **base** R, **rstatix** and **gtsummary*. Though we have highlighted a few common ones, there are many other tests you can use.

Each of the above packages bring certain advantages and disadvantages:

* **base** R easily prints statistical outputs to the R console
* **rstatix** return results in a dataframe, or for running tests by group
* **gtsummary** if you want to quickly prepare print publication-ready tables

## **base** R

You can use **base** R functions to conduct statistical tests. The commands are relatively simple and results will print to the R Console for simple viewing. However, the outputs are usually lists and so are harder to manipulate if you want to use the results in subsequent operations.

### T-tests

A t-test is typically used to determine if there is a significant difference between the means of numeric variables between two tests. There are two ways of writing the syntax for tests, either you specify the data and the columns separated by a tilde (`~`):

```{r, echo = T, eval = T}
## compare mean age by outcome group with a t-test
t.test(age_years ~ gender, data = linelist)
```

or for distinguishing between separate numeric vectors, you can call the columns directly using `$` to denote the column,

```{r, echo = T, eval = F}
## compare mean age by outcome group with a t-test
t.test(df1$age_years, df2$age_years)
```

This applies to all of the statistical tests. You can also use a t-test to determine whether a sample mean is significantly different from a specific value.

```{r, echo = T, eval = T}
t.test(linelist$age_years, 
       mu = 45) #Specify the value you want to test against with mu = 
```

### Shapiro-Wilk test

The Shapiro-Wilk test can be used to determine whether a sample came from a normally-distributed population (an assumption of many other tests and analysis, such as the t-test). However, this can only be used on a sample between 3 and 5000 observations. For larger samples a quantile-quantile plot may be helpful.

```{r, echo = T, eval = T}
shapiro.test(subset(linelist, gender == "m")$age_years) #We are subsetting to only males in order to show the output of the test when there are between 3 and 5000 observations
```

### Wilcoxon rank sum test

Also called the Mann-Whitney U test, this statistical test is used to determine if two numeric samples are from the same distribution when their populations are not normally distributed, or have an unequal variance.

```{r, echo = T, eval = T}
## compare age distribution by outcome group with a wilcox test
wilcox.test(age_years ~ outcome, data = linelist)
```

### Kruskal-Wallis test

The Kruskal-Wallis test is an extension of the Wilcoxon rank sum test that can be used to test for differences in the distribution of more than two samples. When only two samples are used it gives identical results to the Wilcoxon rank sum test.

```{r, echo = T, eval = T}
## compare age distribution by outcome group with a kruskal-wallis test
kruskal.test(age_years ~ outcome, data = linelist)
```

### Chi-squared test

Pearson’s Chi-squared test is used in testing for significant differences between categorical groups.

```{r, echo = T, eval = T}
## compare the proportions in each group with a chi-squared test
chisq.test(linelist$gender, linelist$outcome)
```

```{r quiz13}
quiz(
  question("Which of these would you use to test if the data is normally distributed?",
           answer("T-test", correct = F),
           answer("Wilcoxon rank sum test", correct = F),
           answer("Shapiro-Wilk test", correct = T),
           answer("Chi-squared test", correct = F),
           answer("Kruskal-Wallis test", correct = F)),
  question("Which of these would you use to test if there is a significant difference in means between two groups?",
           answer("T-test", correct = T),
           answer("Wilcoxon rank sum test", correct = F),
           answer("Shapiro-Wilk test", correct = F),
           answer("Chi-squared test", correct = F),
           answer("Kruskal-Wallis test", correct = F)),
  question("Which of these would you use to test if there is a significant difference between two groups?",
           answer("T-test", correct = F),
           answer("Wilcoxon rank sum test", correct = F),
           answer("Shapiro-Wilk test", correct = F),
           answer("Chi-squared test", correct = T),
           answer("Kruskal-Wallis test", correct = F)),
  question("Which of these could you use to test if two numeric samples from non-normal distributions are from the same distribution?",
           answer("T-test", correct = F),
           answer("Wilcoxon rank sum test", correct = T),
           answer("Shapiro-Wilk test", correct = F),
           answer("Mann-Whitney U test", correct = F),
           answer("Kruskal-Wallis test", correct = T))
           
  )
```

## **rstatix** package

The **rstatix** package offers the ability to run statistical tests and retrieve results in a “pipe-friendly” framework. The results are automatically in a data frame so that you can perform subsequent operations on the results. It is also easy to group the data being passed into the functions, so that the statistics are run for each group.

The function `get_summary_stats()` is a quick way to return summary statistics, if no columns are specified the statistics are calculated for all columns.

By default, a full range of summary statistics are returned: n, max, min, median, 25% quantile, 75% quantile, IQR, median absolute deviation (mad), mean, standard deviation, standard error, and a confidence interval of the mean.

```{r, echo = T, eval = T}
linelist %>%
  rstatix::get_summary_stats(age, temp)
```

It can be used with grouped data as well, such that a row is returned for each grouping variable

```{r, echo = T, eval = T}
linelist %>%
  group_by(hospital) %>%
  rstatix::get_summary_stats(age, temp, type = "common")
```

### T-test

Use the formula syntax to specify the numeric and categorical columns

```{r, echo = T, eval = T}
linelist %>%
  t_test(age_years ~ gender)
```

Or, if you want to specify a one-sample T-test you use `~ 1` and specify `mu = `:

```{r, echo = T, eval = T}
linelist %>%
  t_test(age_years ~ 1, mu = 30)
```

In order to conduct statistical tests by group, add the `group_by()` function to the pipe chain:

```{r, echo = T, eval = T}
linelist %>%
  group_by(gender) %>%
  t_test(age_years ~ 1, mu = 18)
```

### Shapiro-Wilk test

As stated above, sample size must be between 3 and 5000.

```{r, echo = T, eval = T}
linelist %>% 
  head(500) %>%            # first 500 rows of case linelist, for example only
  shapiro_test(age_years)
```

### Wilcoxon rank sum test

```{r, echo = T, eval = T}
linelist %>% 
  wilcox_test(age_years ~ gender)
```

### Kruskal-Wallis test  (Mann-Whitney U test)

```{r, echo = T, eval = T}
linelist %>% 
  kruskal_test(age_years ~ outcome)
```

### Chi-squared test

The chi-square test function accepts a table, so first we create a cross-tabulation. There are many ways to create a cross-tabulation (see Descriptive tables) but here we use `tabyl()` from **janitor** and remove the left-most column of value labels before passing to `chisq_test()`.

```{r, echo = T, eval = T}
linelist %>% 
  tabyl(gender, outcome) %>% 
  select(-1) %>% 
  chisq_test()
```

## **gtsummary** package

Use **gtsummary** if you are looking to add the results of a statistical test to a pretty table that was created with this package (as described in the **gtsummary** section of the Descriptive tables page).

Performing statistical tests of comparison with `tbl_summary()` is done by adding the `add_p()` function to a table and specifying which test to use. It is possible to get p-values corrected for multiple testing by using the add_q function. Run `?tbl_summary` for details.

### Chi-squared test

Compare the proportions of a categorical variable in two groups. The default statistical test for `add_p()` when applied to a categorical variable is to perform a chi-squared test of independence with continuity correction, but if any expected call count is below 5 then a Fisher’s exact test is used.

### T-tests

Compare the difference in means for a continuous variable in two groups. For example, compare the mean age by patient outcome.

```{r, echo = T, eval = T}
linelist %>% 
  select(age_years, outcome) %>%             # keep variables of interest
  tbl_summary(                               # produce summary table
    statistic = age_years ~ "{mean} ({sd})", # specify what statistics to show
    by = outcome) %>%                        # specify the grouping variable
  add_p(age_years ~ "t.test")                # specify what tests to perform
```

### Wilcoxon rank sum test 

Compare the distribution of a continuous variable in two groups. The default is to use the Wilcoxon rank sum test and the median (IQR) when comparing two groups. However for non-normally distributed data or comparing multiple groups, the Kruskal-wallis test is more appropriate.

```{r, echo = T, eval = T}
linelist %>% 
  select(age_years, outcome) %>%                       # keep variables of interest
  tbl_summary(                                         # produce summary table
    statistic = age_years ~ "{median} ({p25}, {p75})", # specify what statistic to show (this is default so could remove)
    by = outcome) %>%                                  # specify the grouping variable
  add_p(age_years ~ "wilcox.test")                     # specify what test to perform (default so could leave brackets empty)
```

### Kruskal-wallis test 

```{r, echo = T, eval = T}
linelist %>% 
  select(age_years, outcome) %>%                       # keep variables of interest
  tbl_summary(                                         # produce summary table
    statistic = age_years ~ "{median} ({p25}, {p75})", # specify what statistic to show (default, so could remove)
    by = outcome) %>%                                  # specify the grouping variable
  add_p(age_years ~ "kruskal.test")                    # specify what test to perform
```

In addition to carrying out tests individually, you can specify them all at once by including the tests in a `list()`. For example:

```{r, echo = T, eval = T}
linelist %>% 
  select(age_years, outcome) %>%                       # keep variables of interest
  tbl_summary(                                         # produce summary table
    statistic = age_years ~ "{median} ({p25}, {p75})", # specify what statistic to show (default, so could remove)
    by = outcome) %>%                                  # specify the grouping variable
  add_p(list(age_years ~ "kruskal.test",
             age_years ~ "t.test"))
```

Now we're going to use what you've learned in order to analyse the `linelist`. Can you select `hospital` and `outcome` then produce a table summary including a Chi-squared test?

```{r gtsummary_test_chisq, exercise = TRUE}
linelist %>%
  
```

```{r gtsummary_test_chisq-hint}

```

```{r gtsummary_test_chisq-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal()
    # Default to failing grade with feedback
    fail()
  })
```

```{r gtsummary_test_chisq-solution}
linelist %>% 
  select(hospital, outcome) %>%    # keep variables of interest
  tbl_summary(by = outcome) %>%  # produce summary table and specify grouping variable
  add_p()
  
```

## Correlations

Correlation between numeric variables can be investigated using the **tidyverse**
**corrr** package. It allows you to compute correlations using Pearson, Kendall tau or Spearman rho. The package creates a table and also has a function to automatically plot the values.

```{r, echo = T, eval = T}
correlation_tab <- linelist %>% 
  select(generation, age, ct_blood, days_onset_hosp, wt_kg, ht_cm) %>%   # keep numeric variables of interest
  correlate()      # create correlation table (using default pearson)

correlation_tab    # print
```

```{r, echo = T, eval = T}
## remove duplicate entries (the table above is mirrored) 
correlation_tab <- correlation_tab %>% 
  shave()

## view correlation table 
correlation_tab

rplot(correlation_tab)
```


