---
title: "Data cleaning"
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
description: >
  Learn how to get started with R and RStudio, and how to import a dataset
---

<!-- Add JavaScript code for making the exercise code larger -->
<script language="JavaScript" src="js/exercise-font-size.js"></script>

```{r setup, include=FALSE}
# load packages ----------------------------------------------------------------
library(learnr)
library(gradethis)
library(tidyverse)
library(here)
library(janitor)
library(rio)
library(basket) # not sure if we need this
library(etude) # helper functions for gradethis

# set options for exercises and checking ---------------------------------------
gradethis_setup()

learnr::tutorial_options(exercise.timelimit = 60) 
  #exercise.checker = gradethis::grade_learnr) 
    # alternatively, submitr::null_code_checker


# event recorder ---------------------------------------------------------------
# see https://github.com/dtkaplan/submitr/blob/master/R/make_a_recorder.R
tutorial_options(exercise.eval = FALSE)  # pre-evaluate exercises

vfun <- submitr::make_basic_validator(NULL, "hello") #basket::check_valid

new_recorder <- function(tutorial_id, tutorial_version, user_id, event, data) {
    cat(
      tutorial_id, 
      " (v", tutorial_version, "); ",
      format(Sys.time(), "%Y-%M%-%D %H:%M:%S %Z"), "; ",
      user_id, "; ",
      event, "; ",
      data$label, "; ",
      data$answers, "; ",
      data$code, "; ",
      data$correct, "\n", sep = "",
      
      file = here::here("event_records", "learnr_basics.txt"),
      append = TRUE)
}

options(tutorial.event_recorder = new_recorder)


# hide non-exercise code chunks ------------------------------------------------
knitr::opts_chunk$set(echo = FALSE)


# data prep --------------------------------------------------------------------
linelist_raw <- rio::import(here::here("data", "linelist_raw.xlsx"))
linelist <- rio::import(here::here("data", "linelist_cleaned.rds"))
malaria_counts <- rio::import(here::here("data", "malaria_facility_count_data.rds"))
```


```{r}
submitr::login_controls() # show login and password with "Submit" button.
```


```{r context = "server", echo = FALSE}
# see https://rdrr.io/github/dtkaplan/submitr/f/vignettes/using.Rmd
options(tutorial.storage = "none")
vfun <- submitr::make_basic_validator(NULL, "hello")       #basket::check_valid
storage_actions <- submitr::record_local("./minimal_submissions.csv")
submitr::shiny_logic(input, output, session, vfun,
                     storage_actions)
```




## Introduction to R for Applied Epidemiology and Public Health
### Data cleaning and core functions

```{r appliedepi-banner, fig.margin = TRUE, echo = FALSE, fig.width = 3, out.width = "100%", fig.cap = ""}
knitr::include_graphics("images/moz-banner.png")
```


### Welcome

Welcome to the course "Introduction to R for applied epidemiologists", offered for free by [Applied Epi](www.appliedepi.org) - a non-profit organisation that offers open-source tools, training, and support to frontline public health practitioners.

This interactive tutorial focuses on **cleaning of datasets often encountered by applied epidemiologists and public health practitioners**, such as outbreak linelists, surveillance, and laboratory data.  


#### Target Audience  

This course is designed with the following objectives: 

* To be friendly to people who have never used a programming language before
* To teach R emphasizing examples, datasets, and challenges commonly faced by applied epidemiologists
* To be modular - so that you can skip to section most relevant to you

If this is your first introduction to R programming, please consider first completing our [R Setup and Data Import tutorial], which introduces R, RStudio, R projects, R code syntax, and explains how to import a dataset into R.  



#### Other languages
This course is available...


#### Offline / Online

You can access this tutorial offline by downloading our R package ... 
If viewing offline, you can view the videos by doing ...



#### Learning goals

In this tutorial you will learn and practice:  

* Using the pipe operator (`%>%`) to pass the dataset from one cleaning function to another
* The core **tidyverse** R functions used to reduce, clean, and modify data frames  
* How to manipulate dates in order to clean and translate between units of time (days/months/years) with the **lubridate** package
* The use of descriptive analysis and summary statistics with the **janitor** package in order to summarise your data



This tutorial adapts the [Data cleaning and core functions](https://epirhandbook.com/en/cleaning-data-and-core-functions.html) section of our free [ Epidemiologist R Handbook](https://epirhandbook.com/en/), which is available for use offline as well. 


#### Data consent

We continually improve these tutorials by collecting your entries and submitted answers to the quiz questions. By continuing, you consent to this collection and use.

To continue anonymously... do XYZ.



#### Who made this course  

This course is designed by epidemiologists with decades of ground-level experience in outbreak response and local public health work. 


```{r appliedepi-hexes, fig.margin = TRUE, echo = FALSE, fig.width = 3, out.width = "50%", fig.cap = ""}
knitr::include_graphics("images/hex-sidebyside.png")
```


## Data used and directory structure

In this tutorial we will use the following datasets. Please take a few minutes to review the structure and content of each dataset before continuing.

Use the arrows on the right to scroll through hidden columns. Note that these are "raw" (messy) datasets that mimic problems commonly found in real-life epidemiological datasets.  


### **A "linelist" of cases in a fictional (not real) Ebola outbreak***

A "linelist" is a term used in applied epidemiology to refer to a table that contains key information about each case or suspect case in an outbreak. Each row represents one case, and the columns contain variables such as age, sex, date of symptom onset, outcomes, etc.

This dataset contains `r nrow(linelist_raw)` rows and `r ncol(linelist_raw)` columns. Below are the first 5 rows:  

```{r}
head(linelist_raw)
```

Click to [download the **raw** dataset](https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_raw.xlsx) for your own practice.

Click to [download the **clean** dataset as an **.rds file**](https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds) for your own practice. A *.rds file* is an R-specific file type that preserves column classes. This ensures you will have only minimal cleaning to do after importing the data into R.

### **Aggregated data from malaria surveillance in a fictional country**  

Aggregated data in epidemiology usually means a table of counts for each facility, or district, etc. Sometimes, the counts can also be per day, week, or month.  

In this fictional dataset, each facility reported *daily* case counts of rapid-test (RDT)-confirmed malaria. Thus, each row represents the number of cases for a specific facility on a specific day.  

This dataset contains `r nrow(malaria_counts)` rows and `r ncol(malaria_counts)` columns. Below are the first 5 rows:  

```{r}
head(malaria_counts)
```


Click to [download the **clean** malaria counts dataset as an **.rds file**](https://github.com/appliedepi/epirhandbook_eng/raw/master/data/malaria_facility_count_data.rds) for your own practice. A *.rds file* is an R-specific file type that preserves column classes. This ensures you will have only minimal cleaning to do after importing the data into R.


### Directory structure

Photo or GIF of directory structure

### Accessing example data
Here is how to access the example data

### Tidy Data

We highly recommend doing our tutorial on Tidy Data in Applied Epidemiology. Collecting, formatting, and preparing your dataset *before* importing it into R is a critical step!
LINK
VIDEO TEASER




## Install and Load R packages {#packages}

To use basic functions with public health data, the tidyverse metapackage is very useful. Tidyverse loads the dplyr, ggplot2, and other packages that are useful in epi data analysis. 

We've preloaded the below packages for now. Installation and loading of these packages is described on the EpiRHandbook [_Suggested Packages_](https://epirhandbook.com/en/suggested-packages-1.html) page. 


In this assignment we'll work with X R packages, let's load them!

```{r load-package, exercise = TRUE}
pacman::p_load(___)
```

```{r load-package-hint}
pacman::p_load(rio, here, janitor, tidyverse)

```

```{r load-package-check}
grade_this_code("You are correct, the packages you need for this lesson are now loaded!")
```

```{r eval=FALSE}
pacman::p_load(learnr, here, rio, janitor, tidyverse)
```

### Recommended R packages for public health

See this Epi R Handbook LINK for our recommended packages.









## Import data {#import} 
https://www.epirhandbook.com/en/import-and-export.html
Import that data and save it as "raw" file

To import data from a sub-folder, the `import()` command should be modified so that it correctly tells R where to search for this file. This is done using the here() function. 

```{r import-demo-subfolder, echo=T, eval=F}
linelist_raw <- import(here("data", "linelist_raw.xlsx"))   # import data and save as named object
```


## Begin pipe chain
What is a pipe chain?
A pipe chain refers to the use of the "pipe" operator `%>%` to chain together operations (such as cleaning, reordering and manipulating) for altering a dataset. 

This allows us to carry out several different alterations of the dataframe in a single operation. It can be helpful to think of the pipe operator `%>%` as telling the computer "and then" between your operational commands. The order of this pipeline is important as operations occur sequentially, and so improperly ordered arguments may fail or (potentially more dangerously!) give incorrect values or unwanted outcomes.

Can you connect the following commands from the **janitor** package (`clean_names`, `select(contains("date_"))` and `names()` to clean the dataset `linelist_raw` and display the names of any columns that contain "_date"?

```{r pipe_linelist, exercise = TRUE}
linelist_raw %>%
  
```

```{r pipe_linelist-hint}
linelist_raw %>%
  clean_names() %>%

```

```{r pipe_linelist-check}
grade_result(
  pass_if(~ identical(.result, linelist_raw %>%
    clean_names() %>%
    select(contains("date_")) %>%
    names() ), "You have correctly linked the functions in order and displayed the names of the cleaned dataset, good work!")
)
```


```{r eval = FALSE}
linelist_raw %>%                              #Define the dataset, and then
         clean_names() %>%                    #clean the dataset columns, and then
         select(contains("date_")) %>%        #Select columns where their name contains "date_", and then
         names()                              #Display the column names

```


## Pipe chain
If the order of cleaning and selecting columns had not been correct, then you would have missed the column "date_onset" as in the raw linelist it was called "date onset". 

This was a very simple example giving you a first taste of pipe operators and cleaning functions, as we progress through the chapter you will gain more familiarity with the functions available and how to use them in increasingly complex examples.

## Clean columns

In R, column names are the header, or top, value of a column and are used as the default value in figures. In other statistical software (such as SAS and STATA) "labels"  co-exist as longer printed versions of shorter column names, and while R can do this, it is not emphasized and for plotting and printing "friendly" column names, we generally adjust their display in the code to create the figure or tables.

As we call column names often, it is helpful to have a "clean" syntax. We suggest that they are:

*   Short
*   No spaces (replace with underscores)
*   No unusual characters (&, #, <, >, ...)
*   Similar style nomenclature (e.g. all date columns named like **date_**onset, **date_**report, **date_**death, ...)

These are often not what real, raw, data and linelists look like, luckily R has a set of very handy and easy to use tools to clean and standardize column names.

For example, if we look at the example linelist using the `names()` function:
```{r, echo = T, eval = T}
names(linelist_raw)
```
We can see that there are numerous violations of this clean syntax. We have names with spaces (infection date), different naming patterns for dates (date onset vs infection date) and there must have been a merged header across the last two columns (as the second last column i called "merged_header" and the last "...28" indicating it was assigned a placeholder name (it is the 28th column)). 

Manually changing these column names to the preferred clean syntax would be time consuming, error prone and would need to be repeated everytime new versions of the linelist became available. Luckily, R has some helpful functions to make this process much faster and reproducible.

### Clean names

The first function we will explore in detail is the `clean_names()` function from the **janitor** package. This function does a lot of the hard work of cleaning column names for us. It does this through:

* Converting names to consist of only underscores, numbers and letters
* Accented characters are transliterated to ASCII (e.g. german o with umlaut becomes “o”, spanish “enye” becomes “n”)
* Capitalization preference for the new column names can be specified using the case = argument
* You can specify specific name replacements by providing a vector to the replace = argument (e.g. replace = c(onset = "date_of_onset"))

Here we can see the differences in the column names of the cleaned and uncleaned dataset.

```{r, echo = T, eval = T}
linelist_raw %>%                              #Define the dataset, and then
  names()                                     #Display the column names

linelist_raw %>%                              #Define the dataset, and then
         clean_names() %>%                    #clean the dataset columns, and then
         names()                              #Display the column names

```

You can see that this has done a lot of the work for us, replacing spaces with "_", and ensuring there are no unusual characters. However, if we want to standardize the entire dataset to the "clean syntax" described previously, we will have to include additional cleaning stages.

For example, if we wanted to use a similar style nomenclature such as **date_**, then we would have to carry out additional steps to the columns "infection_date", "hosp_date", "date_of_outcome".

This manual name cleaning is done through the function `rename()` from the **dplyr** package as part of a pipe chain. Here the function follows the syntax `r NEW = OLD`. So to clean the linelist, rename the columns previously mentioned and then display the names, we would do the following:

```{r, echo = T, eval = T}
linelist_raw %>%
  clean_names() %>%
         #New name         #Old names
  rename(date_infection = infection_date,
         date_hospitalisation = hosp_date,
         date_outcome = date_of_outcome) %>%
  names()

```

As you can see, the column names have changed. You can also do this by column position, though this is less encouraged as column positions can easily change between datasets and versions. Here we are updating the names of column 1 and 2 to "id" and "gen"

```{r, echo = T, eval = T}
linelist_raw %>%
  clean_names() %>%
         #New name #Old names
  rename(id = 1,
         gen = 2) %>%
  names()
```

### Select columns

Another way of re-naming columns is through the `r select` function. This function subsets your dataset, removing unwanted columns, and additionally allows you to rename the columns you have kept.

```{r, echo = T, eval = T}

linelist_raw %>%
  select(#New name #Old name
    date_infection = 'infection date',
    date_hospitalisation = 'hosp date')

```

As you can see, this has only kept the columns with the original names of `r 'infection date'` and `r 'hosp date'` and renamed them. Note, because of the spaces in the names of the dataset we need to put the column name within `r ' '` as R does not like spaces in column names.

`r select()` does not have to rename, it can also be used to subset a dataset to the columns you are interested in. This can either be done manually, through specifying the columns as in:

```{r, echo = T, eval = T}
linelist_raw %>%
  select(case_id, generation, gender)
```

However, when you have a large dataset with many options to choose from, this can be cumbersome. Sometimes you want to extract columns with a specific prefix/suffix, or where they contain a certain word. 

Rather than manually typing these out, and especially if we have a cleaned dataset adhering to the "clean style" syntax specified previously, we can use "tidyselect" helper functions

## Tidyselect helper functions

Tidyselect helper functions are functions that work within **dplyr** functions such as `r select()`, `r across()` or `r summarise()`. These offer convenient shortcuts for selecting subsets of columns that match specified criteria:

* `r everything()` - all other columns not mentioned
* `r last_col()` - the last column
* `r where()` - applies a function to all columns and selects those which are true
  * example: `r select(where(is.numeric))`
  * This would select all columns where the class is numeric
* `r contains()` - columns containing a character string
  * example: `r select(contains("time"))`
* `r starts_with()` - matches to a specified prefix
  * example: `r select(starts_with("date_"))`
* `r ends_with()` - matches to a specified suffix
  * example: `r select(ends_with("_post"))`
* `r matches()` - to apply a regular expression (regex)
  * example: `r select(matches("[pt]al))`
  * Regular expression (regex) refers to a sequence of characters that specifies a search pattern in text. If you are unfamiliar with regex, then there some aspects may seem non-intuitive, for a good introduction to the use of regex please see https://cran.r-project.org/web/packages/stringr/vignettes/regular-expressions.html.
* `r num_range()` - a numerical range
  * example: `r select(num_range("week", 1:5))`
* `r any_of()` - matches if the column exists, but returns no error if it is not found
  * example: `r select(any_of(date_onset, date_death, cardiac_arrest))`
  
In addition to these we can use normal operators such as:

* `r c()` - to list several columns
  * example: `r select(c(date_onset, hosp_date, gender))`
* `r :` - to select consecutive columns
  * example: `r select(1:5)`
* `r !` - for the opposite
  * example: `r select(!c(date_onset, hosp_date, gender))`
  * This would _not_ select date_onset, hosp_date, gender
* `r &` - AND
  * example: `r select(matches("date" & "outcome"))`
* `r |` - OR
  * example: `r select(matches("date" | "outcome"))`



### Quiz


## Clean rows

### Drop missing values
### Deduplication
Touch upon some of these: https://www.epirhandbook.com/en/de-duplication.html
### Filter by logic
### Quiz




## New columns
### mutate()
### Re-coding
### Quiz




## Dates
See Epi R Handbook chapter on working with dates
https://www.epirhandbook.com/en/working-with-dates.html


### Convert to date
#### Character to date
#### Excel to date

### epiweeks
use floor_date() from lubridate
#### ISO weeks

### Quiz


## Pivots
See Epi R Handbook page on Pivoting
https://www.epirhandbook.com/en/pivoting-data.html
### Quiz

## Joins
https://www.epirhandbook.com/en/joining-data.html
### Quiz

## Next steps


##  TEMPLATE Exercises

### Exercise with Code

*Here's an exercise with some prepopulated code as well as `exercise.lines = 5` to provide a bit more initial room to work.*

Now write a function that adds any two numbers and then call it:

```{r add-function, exercise=TRUE, exercise.lines = 5}
add <- function() {
  
}
```

### Exercise with Hint

*Here's an exercise where the chunk is pre-evaulated via the `exercise.eval` option (so the user can see the default output we'd like them to customize). We also add a "hint" to the correct solution via the chunk immediate below labeled `print-limit-hint`.*

Modify the following code to limit the number of rows printed to 5:

```{r print-limit, exercise=TRUE, exercise.eval=TRUE}
mtcars
```

```{r print-limit-hint}
head(mtcars)
```

### Quiz

*You can include any number of single or multiple choice questions as a quiz. Use the `question` function to define a question and the `quiz` function for grouping multiple questions together.*

Some questions to verify that you understand the purposes of various base and recommended R packages:

```{r quiz}
quiz(
  question("Which package contains functions for installing other R packages?",
    answer("base"),
    answer("tools"),
    answer("utils", correct = TRUE),
    answer("codetools")
  ),
  question("Which of the R packages listed below are used to create plots?",
    answer("lattice", correct = TRUE),
    answer("tools"),
    answer("stats"),
    answer("grid", correct = TRUE)
  )
)
```


