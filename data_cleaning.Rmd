---
title: "Data cleaning"
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
description: >
  Learn how to get started with R and RStudio, and how to import a dataset
---

<!-- Add JavaScript code for making the exercise code larger -->
<script language="JavaScript" src="js/exercise-font-size.js"></script>

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 
# load packages ----------------------------------------------------------------
library(learnr)
library(gradethis)
library(tidyverse)
library(here)
library(janitor)
library(rio)
library(basket) # not sure if we need this
library(etude) # helper functions for gradethis
library(epikit)
library(linelist)
library(lubridate)

# set options for exercises and checking ---------------------------------------
gradethis_setup()

learnr::tutorial_options(exercise.timelimit = 60) 
  #exercise.checker = gradethis::grade_learnr) 
    # alternatively, submitr::null_code_checker


# event recorder ---------------------------------------------------------------
# see https://github.com/dtkaplan/submitr/blob/master/R/make_a_recorder.R
tutorial_options(exercise.eval = FALSE)  # pre-evaluate exercises

vfun <- submitr::make_basic_validator(NULL, "hello") #basket::check_valid

new_recorder <- function(tutorial_id, tutorial_version, user_id, event, data) {
    cat(
      tutorial_id, 
      " (v", tutorial_version, "); ",
      format(Sys.time(), "%Y-%M%-%D %H:%M:%S %Z"), "; ",
      user_id, "; ",
      event, "; ",
      data$label, "; ",
      data$answers, "; ",
      data$code, "; ",
      data$correct, "\n", sep = "",
      
      file = here::here("event_records", "learnr_basics.txt"),
      append = TRUE)
}

options(tutorial.event_recorder = new_recorder)


# hide non-exercise code chunks ------------------------------------------------
knitr::opts_chunk$set(echo = FALSE)


# data prep --------------------------------------------------------------------
linelist_raw <- rio::import(here::here("data", "linelist_raw.xlsx"))
linelist <- rio::import(here::here("data", "linelist_cleaned.rds"))
malaria_counts <- rio::import(here::here("data", "malaria_facility_count_data.rds"))

#Incorrectly assign class so we can clean later
linelist_raw$age <- as.character(linelist_raw$age)
linelist_raw$`date onset` <- as.character(linelist_raw$`date onset`)

#Going to randomly convert some temperatures to Fahrenheit instead of celcius for an exercise later
set.seed(1)
take_these <- sample(1:nrow(linelist_raw), 500)

linelist_raw$temp[take_these] <- (linelist_raw$temp[take_these] * 9/5) + 32

```


```{r}
submitr::login_controls() # show login and password with "Submit" button.
```


```{r context = "server", echo = FALSE}
# see https://rdrr.io/github/dtkaplan/submitr/f/vignettes/using.Rmd
options(tutorial.storage = "none")
vfun <- submitr::make_basic_validator(NULL, "hello")       #basket::check_valid
storage_actions <- submitr::record_local("./minimal_submissions.csv")
submitr::shiny_logic(input, output, session, vfun,
                     storage_actions)
```




## Introduction to R for Applied Epidemiology and Public Health
### Data cleaning and core functions

```{r appliedepi-banner, fig.margin = TRUE, echo = FALSE, fig.width = 3, out.width = "100%", fig.cap = ""}
knitr::include_graphics("images/moz-banner.png")
```


### Welcome

Welcome to the course "Introduction to R for applied epidemiologists", offered for free by [Applied Epi](www.appliedepi.org) - a non-profit organisation that offers open-source tools, training, and support to frontline public health practitioners.

This interactive tutorial focuses on **cleaning of datasets often encountered by applied epidemiologists and public health practitioners**, such as outbreak linelists, surveillance, and laboratory data.  


#### Target Audience  

This course is designed with the following objectives: 

* To be friendly to people who have never used a programming language before
* To teach R emphasizing examples, datasets, and challenges commonly faced by applied epidemiologists
* To be modular - so that you can skip to section most relevant to you

If this is your first introduction to R programming, please consider first completing our [R Setup and Data Import tutorial], which introduces R, RStudio, R projects, R code syntax, and explains how to import a dataset into R.  



#### Other languages
This course is available...


#### Offline / Online

You can access this tutorial offline by downloading our R package ... 
If viewing offline, you can view the videos by doing ...



#### Learning goals

In this tutorial you will learn and practice:  

* Using the pipe operator (`%>%`) to pass the dataset from one cleaning function to another
* The core **tidyverse** R functions used to reduce, clean, and modify data frames  
* How to manipulate dates in order to clean and translate between units of time (days/months/years) with the **lubridate** package
* The use of descriptive analysis and summary statistics with the **janitor** package in order to summarise your data



This tutorial adapts the [Data cleaning and core functions](https://epirhandbook.com/en/cleaning-data-and-core-functions.html) section of our free [ Epidemiologist R Handbook](https://epirhandbook.com/en/), which is available for use offline as well. 


#### Data consent

We continually improve these tutorials by collecting your entries and submitted answers to the quiz questions. By continuing, you consent to this collection and use.

To continue anonymously... do XYZ.



#### Who made this course  

This course is designed by epidemiologists with decades of ground-level experience in outbreak response and local public health work. 


```{r appliedepi-hexes, fig.margin = TRUE, echo = FALSE, fig.width = 3, out.width = "50%", fig.cap = ""}
knitr::include_graphics("images/hex-sidebyside.png")
```


## Data used and directory structure

In this tutorial we will use the following datasets. Please take a few minutes to review the structure and content of each dataset before continuing.

Use the arrows on the right to scroll through hidden columns. Note that these are "raw" (messy) datasets that mimic problems commonly found in real-life epidemiological datasets.  


### **A "linelist" of cases in a fictional (not real) Ebola outbreak***

A "linelist" is a term used in applied epidemiology to refer to a table that contains key information about each case or suspect case in an outbreak. Each row represents one case, and the columns contain variables such as age, sex, date of symptom onset, outcomes, etc.

This dataset contains `r nrow(linelist_raw)` rows and `r ncol(linelist_raw)` columns. Below are the first 5 rows:  

```{r}
head(linelist_raw)
```

Click to [download the **raw** dataset](https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_raw.xlsx) for your own practice.

Click to [download the **clean** dataset as an **.rds file**](https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds) for your own practice. A *.rds file* is an R-specific file type that preserves column classes. This ensures you will have only minimal cleaning to do after importing the data into R.

### **Aggregated data from malaria surveillance in a fictional country**  

Aggregated data in epidemiology usually means a table of counts for each facility, or district, etc. Sometimes, the counts can also be per day, week, or month.  

In this fictional dataset, each facility reported *daily* case counts of rapid-test (RDT)-confirmed malaria. Thus, each row represents the number of cases for a specific facility on a specific day.  

This dataset contains `r nrow(malaria_counts)` rows and `r ncol(malaria_counts)` columns. Below are the first 5 rows:  

```{r}
head(malaria_counts)
```


Click to [download the **clean** malaria counts dataset as an **.rds file**](https://github.com/appliedepi/epirhandbook_eng/raw/master/data/malaria_facility_count_data.rds) for your own practice. A *.rds file* is an R-specific file type that preserves column classes. This ensures you will have only minimal cleaning to do after importing the data into R.


### Directory structure

Photo or GIF of directory structure

### Accessing example data
Here is how to access the example data

### Tidy Data

We highly recommend doing our tutorial on Tidy Data in Applied Epidemiology. Collecting, formatting, and preparing your dataset *before* importing it into R is a critical step!
LINK
VIDEO TEASER




## Install and Load R packages {#packages}

To use basic functions with public health data, the tidyverse metapackage is very useful. Tidyverse loads the dplyr, ggplot2, and other packages that are useful in epi data analysis. 

We've preloaded the below packages for now. Installation and loading of these packages is described on the EpiRHandbook [_Suggested Packages_](https://epirhandbook.com/en/suggested-packages-1.html) page. 


In this assignment we'll work with X R packages, let's load them!

```{r load-package, exercise = TRUE}
pacman::p_load(___)
```

```{r load-package-hint}
pacman::p_load(rio, here, janitor, tidyverse)

```

```{r load-package-check}
grade_this_code("You are correct, the packages you need for this lesson are now loaded!")
```

```{r eval=FALSE}
pacman::p_load(learnr, here, rio, janitor, tidyverse)
```

### Recommended R packages for public health

See this Epi R Handbook LINK for our recommended packages.


## Import data {#import} 
https://www.epirhandbook.com/en/import-and-export.html
Import that data and save it as "raw" file

To import data from a sub-folder, the `import()` command should be modified so that it correctly tells R where to search for this file. This is done using the here() function. 

```{r import-demo-subfolder, echo=T, eval=F}
linelist_raw <- import(here("data", "linelist_raw.xlsx"))   # import data and save as named object
```


## Begin pipe chain
What is a pipe chain?
A pipe chain refers to the use of the "pipe" operator `%>%` to chain together operations (such as cleaning, reordering and manipulating) for altering a dataset. 

This allows us to carry out several different alterations of the dataframe in a single operation. It can be helpful to think of the pipe operator `%>%` as telling the computer "and then" between your operational commands. The order of this pipeline is important as operations occur sequentially, and so improperly ordered arguments may fail or (potentially more dangerously!) give incorrect values or unwanted outcomes.

Can you connect the following commands from the **janitor** package (`clean_names`, `select(contains("date_"))` and `names()` to clean the dataset `linelist_raw` and display the names of any columns that contain "_date"?

```{r pipe_linelist, exercise = TRUE}
linelist_raw %>%
  
```

```{r pipe_linelist-hint}
linelist_raw %>%
  clean_names() %>%

```

```{r pipe_linelist-check}
grade_result(
  pass_if(~ identical(.result, linelist_raw %>%
    clean_names() %>%
    select(contains("date_")) %>%
    names() ), "You have correctly linked the functions in order and displayed the names of the cleaned dataset, good work!")
)
```


```{r eval = FALSE}
linelist_raw %>%                              #Define the dataset, and then
         clean_names() %>%                    #clean the dataset columns, and then
         select(contains("date_")) %>%        #Select columns where their name contains "date_", and then
         names()                              #Display the column names

```

If the order of cleaning and selecting columns had not been correct, then you would have missed the column "date_onset" as in the raw linelist it was called "date onset". 

This was a very simple example giving you a first taste of pipe operators and cleaning functions, as we progress through the chapter you will gain more familiarity with the functions available and how to use them in increasingly complex examples.

## Column names

In R, column names are the header, or top, value of a column and are used as the default value in figures. In other statistical software (such as SAS and STATA) "labels"  co-exist as longer printed versions of shorter column names, and while R can do this, it is not emphasized and for plotting and printing "friendly" column names, we generally adjust their display in the code to create the figure or tables.

As we call column names often, it is helpful to have a "clean" syntax. We suggest that they are:

*   Short
*   No spaces (replace with underscores)
*   No unusual characters (&, #, <, >, ...)
*   Similar style nomenclature (e.g. all date columns named like "**date_**"onset, "**date_**"report, "**date_**"death, ...)

These are often not what real, raw, data and linelists look like, luckily R has a set of very handy and easy to use tools to clean and standardize column names.

For example, if we look at the example linelist using the `names()` function:
```{r, echo = T, eval = T}
names(linelist_raw)
```
We can see that there are numerous violations of this clean syntax. We have names with spaces (infection date), different naming patterns for dates (date onset vs infection date) and there must have been a merged header across the last two columns (as the second last column i called "merged_header" and the last "...28" indicating it was assigned a placeholder name (it is the 28th column)). 

Manually changing these column names to the preferred clean syntax would be time consuming, error prone and would need to be repeated everytime new versions of the linelist became available. Luckily, R has some helpful functions to make this process much faster and reproducible.

### Automatic cleaning

The first function we will explore in detail is the `clean_names()` function from the **janitor** package. This function does a lot of the hard work of cleaning column names for us. It does this through:

* Converting names to consist of only underscores, numbers and letters
* Accented characters are transliterated to ASCII (e.g. german o with umlaut becomes “o”, spanish “enye” becomes “n”)
* Capitalization preference for the new column names can be specified using the case = argument
* You can specify specific name replacements by providing a vector to the replace = argument (e.g. replace = c(onset = "date_of_onset"))

Here we can see the differences in the column names of the cleaned and uncleaned dataset.

```{r, echo = T, eval = T}
linelist_raw %>%                              #Define the dataset, and then
  names()                                     #Display the column names

linelist_raw %>%                              #Define the dataset, and then
         clean_names() %>%                    #clean the dataset columns, and then
         names()                              #Display the column names

```

You can see that this has done a lot of the work for us, replacing spaces with "_", and ensuring there are no unusual characters. However, if we want to standardize the entire dataset to the "clean syntax" described previously, we will have to include additional cleaning stages.

For example, if we wanted to use a similar style nomenclature such as "**date_**", then we would have to carry out additional steps to the columns "infection_date", "hosp_date", "date_of_outcome".

### Manual name cleaning

This manual name cleaning can be done through the function `rename()` from the **dplyr** package as part of a pipe chain. Here the function follows the syntax `NEW = OLD`. So to clean the linelist, rename the columns previously mentioned and then display the names, we would do the following:

```{r, echo = T, eval = T}
linelist_raw %>%
  clean_names() %>%
         #New name         #Old names
  rename(date_infection = infection_date,
         date_hospitalisation = hosp_date,
         date_outcome = date_of_outcome) %>%
  names()

```

As you can see, the column names have changed. You can also do this by column position, though this is less encouraged as column positions can easily change between datasets and versions. Here we are updating the names of column 1 and 2 to "id" and "gen"

```{r, echo = T, eval = T}
linelist_raw %>%
  clean_names() %>%
         #New name #Old names
  rename(id = 1,
         gen = 2) %>%
  names()
```


```{r quiz0}
quiz(
  question("What arguments would you specify to change the column name 'aches' to 'malaise'?",
    answer("rename(aches = malaise)"),
    answer("clean_names()"),
    answer("names(aches = malaise)"),
    answer("rename(malaise = aches)", correct = TRUE)
  )
)
```

### Select columns

Another way of re-naming columns is through the `select()` function. This function subsets your dataset, removing unwanted columns, and allowing you to rename the columns you have kept.

```{r, echo = T, eval = T}

linelist_raw %>%
  select(#New name #Old name
    date_infection = 'infection date',
    date_hospitalisation = 'hosp date')

```

As you can see, this has subset to the columns with the original names of `'infection date'` and `'hosp date'` and renamed them. Note, because of the spaces in the names of the dataset we need to put the column name within ' ' as R does not like spaces in column names.

`select()` can be used without renaming in order to subset a dataset to the columns you are interested in.

```{r, echo = T, eval = F}
linelist_raw %>%
  select(case_id, generation, gender)
```

Using what we have learned, can you `clean()`, `rename()`, `select()` and `head()` to recreate the output below?

```{r}
  linelist_raw %>%                                        #Define the dataset, and then
         clean_names() %>%                              #clean the dataset columns, and then
                #New name   Old name
         rename(date_infection = infection_date,
                date_outcome = date_of_outcome) %>%     #rename the select columns, and then
         select(case_id, date_infection, date_outcome) %>%
         head()
```

```{r clean_rename_select, exercise = TRUE}

```

```{r clean_rename_select-hint}
Remember the order of your pipe chain is important.
```

```{r clean_rename_select-check}
grade_result(
  pass_if(~ identical(.result, linelist_raw %>%
         clean_names() %>%
         rename(date_infection = infection_date,
                date_outcome = date_of_outcome) %>%
         select(case_id, date_infection, date_outcome) %>%
         head()), "Excellent, you have cleaned the dataset and subset to the columns you want")
)
```

```{r eval = FALSE}
linelist_raw %>%                                        #Define the dataset, and then
         clean_names() %>%                              #clean the dataset columns, and then
                #New name   Old name
         rename(date_infection = infection_date,
                date_outcome = date_of_outcome) %>%     #rename the select columns, and then
         select(case_id, date_infection, date_outcome) %>%
         head()
```

This gives you an insight into how to clean and subset a dataset, however when you have a large dataset manually specifiying columns can be cumbersome. Sometimes you want to extract columns with a specific prefix/suffix, or when they contain a certain word. 

Rather than manually typing these out, and especially if we have a cleaned dataset adhering to the "clean style" syntax specified previously, we can use "tidyselect" helper functions

### Tidyselect helper functions

Tidyselect helper functions are functions that work within **dplyr** functions such as `select()`, `across()` or `summarise()`. These offer convenient shortcuts for selecting subsets of columns that match specified criteria:

* `everything()` - all othecolumns not mentioned
* `last_col()` - the last column
* `where()` - applies a function to all columns and selects those which are true
  * example: `select(where(is.numeric))`
  * This would select all columns where the class is numeric
* `contains()` - columns containing a character string
  * example: `select(contains("time"))`
* `starts_with()` - matches to a specified prefix
  * example: `select(starts_with("date_"))`
* `ends_with()` - matches to a specified suffix
  * example: `select(ends_with("_post"))`
* `matches()` - to apply a regulaexpression (regex)
  * example: `select(matches("[pt]al))`
  * Regulaexpression (regex) refers to a sequence of characters that specifies a search pattern in text. If you are unfamiliawith regex, then there some aspects may seem non-intuitive, foa good introduction to the use of regex please see https://cran.r-project.org/web/packages/stringr/vignettes/regular-expressions.html.
* `num_range()` - a numerical range
  * example: `select(num_range("week", 1:5))`
* `any_of()` - matches if the column exists, but returns no erroif it is not found
  * example: `select(any_of(date_onset, date_death, cardiac_arrest))`
  
In addition to these we can use normal operators such as:

* `c()` - to list several columns
  * example: `select(c(date_onset, hosp_date, gender))`
* `:` - to select consecutive columns
  * example: `select(1:5)`
* `!` - fothe opposite
  * example: `select(!c(date_onset, hosp_date, gender))`
  * This would _not_ select date_onset, hosp_date, gender
* `&` - AND
  * example: `select(matches("date" & "outcome"))`
* `|` - OR
  * example: `select(matches("date" | "outcome"))`

Select can also be used to remove columns, rather than keep, by putting the minus symbol "-" in front of the column name

```{r, eval = T, echo = T}
linelist %>%
  select(-c(date_onset, fever:vomit)) %>% #This will remove date_onset and all columns from fever to vomit
  names()
```

You can also remove a column using base R syntax, by defining it as NULL. For example:
```{r, eval = F, echo = T}
linelist$date_onset <- NULL #Deletes column with base R syntax
```

###
```{r quiz1}
quiz(
  question("Which of these column names follows a clean syntax?",
    answer("date hospitalisation"),
    answer("date_of_patient_hospitalisation"),
    answer("date@hospitalisation"),
    answer("date_hosp", correct = TRUE)
  ),
  question("Which of these functions can be used to rename columns?",
           answer("rename()", correct = TRUE),
           answer("clean_names()", correct = TRUE),
           answer("head()"),
           answer("select()", correct = TRUE)
           ),
  question("Why is it useful to follow a similar style nomenclature (all date columns starting *date_*) for column names?",
    answer("It looks good when you output tables and figures"),
    answer("It helps us find relevant columns and makes omissions/errors less likely", correct = TRUE),
    answer("R is very inflexible and only allows certain combinations of words"),
    answer("It allows us to sort the dataset by alphabetical order")
  ),
  question("In which order would you place these functions in order to output only the names of the columns 'date_onset' and 'outcome' from linelist_raw",
           answer("clean_names(), select(date_onset, outcome), names()", correct = TRUE),
           answer("select(date_onset, outcome), clean_names(), names()"),
           answer("clean_names(), select(-c(date_onset, outcome)), names()"),
           answer("clean_names(), select(date_onset, outcome), head()")
           )
   
)
```

Can you write a pipe chain that drops the columns from `lon` to `source` from linelist_raw?

```{r drop_lon_to_source, exercise = TRUE}

```

```{r drop_lon_to_source-hint}
It is good practice to clean your column names, but it is not necessary to in this example. 

Remember, you do not need to specifiy each column name individually that you want to drop between two columns
```

```{r drop_lon_to_source-check}
grade_result(
  pass_if(~ identical(.result, linelist_raw %>%
         select(-c(lon:source)) ), "Good work, ':' is a useful tool for referencing several concurrent columns.")
)
```

```{r eval = FALSE}
linelist_raw %>%                    #Define the dataset, and then
         select(-c(lon:source))     #Remove all columns between lon and source
```

We need to put all columns with a "date" in them into the same nomenclature (*date_*) and then subset linelist_raw to contain these and all symptom columns.
How would you do this using only `clean_names()` and `select()`?

```{r date_symptom_subset, exercise = TRUE}

```

```{r date_symptom_subset-hint}
You will have to combine renaming, a tidyselect helper function and a normal operator within select() to efficiently clean and subset
```

```{r date_symptom_subset-check}
grade_result(
  pass_if(~ identical(.result, linelist_raw %>%
  clean_names() %>%
  select(date_infection = infection_date,
         date_hospitalisation = hosp_date,
         starts_with("date_"),
         fever:vomit) ), "Combining multiple operations within a select function allows us to efficiently clean, rename and subset data. Nice one.")
)
```

```{r eval = FALSE}
linelist_raw %>%
  clean_names() %>%
  select(date_infection = infection_date,
         date_hospitalisation = hosp_date,
         starts_with("date_"),
         fever:vomit)
```

## Column creation and transformation

Creating new columns and transforming existing ones is easily done in R, where we recommend using the **dplyr** package function `mutate()` which uses the syntax `NEW = VALUE/TRANSFORMATION`.

For example, this would create a new column called `new_col` where each row has the value of 10.

```{r eval = F, echo = T}
linelist %>%
  mutate(new_col = 10)
```

You can also reference pre-existing columns to perform calculations. For example, to calculate the Body Mass Index (BMI) we can use the formula BMI = kg/m^2 using the column `ht_cm` and `wt_kg` through:
```{r eval = T, echo = T}
linelist %>%
  mutate(bmi = wt_kg/(ht_cm/100)^2) %>%
  select(wt_kg, ht_cm, bmi) %>%          #This selects just the wt_kg, ht_cm and bmi columns
  head()                                 #This displays the top 6 rows to check
```

In base R this would be carried out with
```{r, echo = T, eval = F}
linelist$bmi = linelist$wt_kg / (linelist$ht_cm / 100) ^ 2)
```

We can also create multiple new columns at once, which are separated with a comma and should begin on a new line
```{r eval = T, echo = T}
linelist %>%                       
  mutate(
    new_var_dup    = case_id,             # new column = duplicate/copy another existing column
    new_var_static = 7,                   # you can create static variables that are the same for each row
    new_var_static = new_var_static + 5,  # you can overwrite a column, and it can be a calculation using other variables
    ) %>% 
  select(case_id, hospital, date_hospitalisation, contains("new")) %>%
  head()
```


```{r quiz2}
quiz(
  question("Which function can be used to create new columns?",
    answer("select()"),
    answer("mutate()", correct = TRUE),
    answer("rename()"),
    answer("clean_names()")
  ))
```

Can you take what you have learned in the previous chapters and create a new column called `age_months` from `age`, and then subset to only include `age`, `age_months` and `gender`? Note, you should ensure that all values in age are the same unit (specified in `age_unit`), and convert according to this.

```{r date_mutate, exercise = TRUE}

```

```{r date_mutate-hint}
You can use ifelse() to carry out different operations based on another value, this is a vectorised version of the if statement, and so will run through each row of a column and return an answer
ifelse(age_unit == "years",   #The condition, if the value in the column age_unit DOES equal years then the function will return...
       age * 12,              #this value, and if the value in column age_unit DOES NOT equal years, then the function will return...
       age                    #the value in age without manipulation
)
```

```{r date_mutate-check}
grade_result(
  pass_if(~ identical(.result, linelist %>%
  mutate(age_months = ifelse(age_unit == "years", age * 12, age)) %>%
  select(age, age_months, gender)), "Great, you have created a new column based and learned about the ifelse() function.")
)

```

### Converting column class

Columns contain values that are dates, numbers or logical values (TRUE/FALSE) and will only behave if correctly classified. Trying to sum "2" and "1" of class character will return an error, and summing 2 and 1 of class numeric will return 3.

The class of a column is displayed when we use `skim()` and individually we can check the value of columns with `class()`. For instance,

```{r, echo = T, eval = T}
class(linelist_raw$age)
```

we can see that this column has been incorrectly assigned as "character". Can you reassign the class of this column to numeric using `as.numeric()`?

```{r change_class, exercise = T}
linelist %>%
  
```

```{r change_class-check}
grade_result(
  pass_if(~ identical(.result, linelist %>%
    mutate(age = as.numeric(age))), "Great, you've got the hang of changing class!")
)

```

Using the same syntax you can convert columns to character with `as.character()` or to logical operators, `as.logical()` or to a factor with `as.factor()` with base R, or `as_factor` from the package **forcats**.

Converting dates is slightly trickier, and it requires careful attention to the format (e.g. "Month/Day/Year" or "Day/Month/Year"). After converting to the class Date, check your data to confirm each value was converted correctly.

### Grouping data

Often your data will be grouped, and so functions such as `mutate()` will behave differently than if the data is not grouped. Additionally, summarising functions such as `mean()`, `min()`, `max()` will calculate by group and not by all the rows.

```{r, eval = T, echo = T}
# age normalized to mean of ALL rows
linelist %>% 
    summarise(mean_age = mean(age, na.rm = T))

# age normalized to mean of hospital group
linelist %>% 
    group_by(hospital) %>% 
    summarise(mean_age = mean(age, na.rm = T))
```

### Transform multiple columns

The function across() allows us to apply a function to everything specified within it. Columns are specified using the `.cols =` function, either individually, or with "tidyselect" helper functions. The function to apply to these columns is then specified with `.fns = ` (note the function is specified _without_ parentheses "()").

```{r, eval = T, echo = T}
linelist %>%
  mutate(across(.cols = c(temp, ht_cm, wt_kg), .fns = as.character))
```

```{r quiz3}
quiz(
  question("What will this pipe chain do?",
    answer("Check the columns temp, ht_cm and wt_kg to see if they are the character class and return a TRUE/FALSE"),
    answer("Check the columns temp, ht_cm and wt_kg to see if they are the character class"),
    answer("Convert the columns temp, ht_cm and wt_kg to character class and make new columns"),
    answer("Convert the columns temp, ht_cm and wt_kg to character class and update existing columns", correct = TRUE)
  ))
```

Can you update the above function using "tidyselect" helper functions to convert any columns that contain "date" to character?

```{r tidyselect_date_character, exercise = T}

```

```{r tidyselect_date_character-check}
grade_result(
  pass_if(~ identical(.result, linelist %>%
  mutate(across(.cols = contains("date"), .fns = as.character))), "Great work")
)
```

### coalesce()

This **dplyr** function allows us to "fill in" missing values with the first available value in an order you specify. For example, you have two vectors, one containing the patient’s village of detection and another containing the patient’s village of residence. You can use coalesce to pick the first non-missing value for each index:

```{r, eval = T, echo = T}
village_detection <- c("a", "b", NA,  NA)
village_residence <- c("a", "c", "a", "d")

village <- coalesce(village_detection, village_residence)
village    # print
```

This works the same way for a dataset

```{r, eval = T, echo = T}
linelist %>% 
  transmute(first_date = coalesce(date_infection, date_onset),#transmute() is the same as mutate(), except it drops everything not specified in the brackets
            date_infection, 
            date_onset) %>% 
  head()
```

### Cumulative math

In your datasets, you may want to take cumulative sum/mean/min/max etc values across all the rows in the dataframe. For example, calculating the cumulative sum of cases across an outbreak or per day can give us an idea of how the infection is progressing. To calculate the cumulative sum across the entire outbreak, we would do the following:

```{r}

linelist %>%                                 #Begin with the case linelist, and then
  count(date_onset) %>%                      #count of rows per day, as column 'n' by default, and then
  mutate(cumulative_cases = cumsum(n)) %>%   #new column, of the cumulative sum at each row, and then
  head(10)                                   #display the first 10 rows

```

Can you use what you have learned in order to produce a cumulative sum (in a column called cumulative_cases) of the epidemic by healthcare setting from linelist?

```{r cumulative_sum, exercise = TRUE}
linelist %>% 

```

```{r cumulative_sum-hint}
Remember to use group_by() 

```

```{r cumulative_sum-check}
grade_result(
  pass_if(~ identical(.result, linelist %>% group_by(hospital) %>%
    count(date_onset) %>%
    mutate(cumulative_cases = cumsum(n))), "Great, it's hard to see because we have 1629 rows, but you have correctly grouped and cumulatively summed by hospital!")
)
```

### Deduplication

The package **dplyr** has the function  `distinct()` which removes duplicated rows in the dataset, by default it considers all columns though this can be adjusted. Here we will ensure that no rows are 100% duplicates of other rows (evaluated across all columns) in the dataset `linelist_raw`. We are comparing the number of rows in the original and de-duplicated 

```{r}
nrow(linelist_raw)

linelist_raw %>%
  distinct() %>%
  nrow()
```
As you can see the linelist goes from 6611 rows to 6609 These omitted rows would have been 100% duplicates of other rows.

### Quiz

Now we are going to run through everything we have learned so far in order to convert `linelist_raw` into `linelist`, this will require several steps.

* Cleaning names, both automatically and manually renaming date columns to the clean syntax
* Removing the columns "row_num", "merged_header" and "x28"
* De-duplicating
* Adding in the new column "bmi"
* Converting all date columns to the date class, generation and age to numeric class

```{r linelist_raw_to_linelist, exercise = TRUE}


```

```{r linelist_raw_to_linelist-hint}
You have already done each of these steps individually (and some together), this is a case of remembering how to use rename(), select(), mutate() and a few other functions.

```

```{r linelist_raw_to_linelist-check}
grade_result(
  pass_if(~ identical(.result, linelist_raw %>%
  janitor::clean_names() %>% 
  rename(date_infection       = infection_date,
         date_hospitalisation = hosp_date,
         date_outcome         = date_of_outcome) %>% 
  select(-c(row_num, merged_header, x28)) %>% 
  distinct() %>% 
  mutate(bmi = wt_kg / (ht_cm/100)^2) %>% 
  mutate(across(contains("date"), as.Date), 
         generation = as.numeric(generation),
         age = as.numeric(age)) ), "You have strung together numerous functions in order to create a clean dataset, you are well on your way to becoming a data cleaning expert.")
)
```

## Re-code values

You will occasionally have to re-code values, this can be due to a number of reasons

* To edit one specific value (e.g. one date in the wrong format)
* To reconcile values not spelled the same
* To create a new column of categorical values
* To create a new column of numeric categories (e.g. age categories)

### Specific values

To change values manually we can use the `recode()` function within `mutate()`. For instance, to fix a date that has been incorrectly included we use the following:
```{r, echo = F, eval = F}
linelist %>%                             #Old value     #New value
  mutate(date_onset = recode(date_onset, "2014-14-15" = "2014-04-15"))
```

Another example of when you would use recode is if you have a column with several different spellings and missing values.

```{r, echo = T, eval = T}
table(linelist_raw$hospital, useNA = "always")  # print table of all unique values, including missing  
```

As you can see, we need to do some manual cleaning in order to correct misspellings. 

```{r, echo = T, eval = T}
linelist_updated <- linelist_raw %>% 
  mutate(hospital = recode(hospital,
                     # for reference: OLD = NEW
                      "Mitylira Hopital"  = "Military Hospital",
                      "Mitylira Hospital" = "Military Hospital",
                      "Military Hopital"  = "Military Hospital",
                      "Port Hopital"      = "Port Hospital",
                      "Central Hopital"   = "Central Hospital",
                      "other"             = "Other",
                      "St. Marks Maternity Hopital (SMMH)" = "St. Mark's Maternity Hospital (SMMH)"
                      ))

table(linelist_updated$hospital, useNA = "always")

```

### Simple logic

We can also re-code based on logical criteria, you can use `replace()` within `mutate()` and use it with logical conditions in order to specify which rows to change using the following general syntax

```{r, eval = F, echo = T}
mutate(col_to_change = replace(col_to_change, criteria for rows, new value))
```

For instance, if you know a row that is identified with a certain id has the wrong value (such as gender), you can correct this using a logical condition. 
```{r, eval = F, echo = T}
linelist %>% 
  mutate(gender = replace(gender, case_id == "2195", "Female"))
```

This will find the row with the `case_id` of "2195" and change the gender to "Female".

Another useful tool for simple logic is `ifelse()`, `if_else()` and `case_when()`. These "if else" commands are simplified versions of an `if` and `else` programming statement with the general syntax of
```{r, eval = F, echo = T}
ifelse(condition, value to return if condition evaluates to TRUE, value to return if condition evaluates to FALSE)
```

Here we are creating a column `source_known` column where the value of a row is "known" if the row's value in column `source` is _not_ missing. If it _is_ missing then it will be set to "unknown"

```{r, eval = F, echo = T}
linelist %>% 
  mutate(source_known = ifelse(!is.na(source), "known", "unknown"))
```

if_else() is a function from **dplyr** that handles dates. Note that if the "true" value is a date, the "false" value must also qualify a date, hence the use of `NA_real_` instead of `NA`.
```{r, eval = F, echo = T}
linelist %>% 
  mutate(date_death = if_else(outcome == "Death", date_outcome, NA_real_))
```

```{r quiz4}
quiz(
  question("Which of these simple logical statements would replace 'Other' with 'Unidentified' in the column 'hospital'?",
    answer("mutate(hospital = ifelse(hospital == 'Other', 'Unidentified', hospital))", correct = TRUE),
    answer("mutate(hospital = ifelse(hospital == 'Unidentified', 'Other', hospital))"),
    answer("mutate(hospital = ifelse(hospital == 'Other', 'Unidentified', 'Identified'))"),
    answer("mutate(hospital = ifelse(Other == 'hospital', 'Unidentified', hospital))")
  ))
```

### Complex logic

Complex logic takes simple logic to the next level and allows us to input several different criteria. For example, if you are re-coding into several new groups you can use **dplyr**'s `case_when()` function. 

`case_when()` command consists of logical statements and outcomes seperated by a "tilde" `~`. The logic criteria are on the left and the values on the right with statements seperated by commas.

For example, here we utilize the columns `age` and `age_unit` to create a column `age_years`:

```{r, echo = T, eval = F}
linelist <- linelist %>% 
  mutate(age_years = case_when(
            age_unit == "years"  ~ age,       # if age is given in years
            age_unit == "months" ~ age/12,    # if age is given in months
            is.na(age_unit)      ~ age,       # if age unit is missing, assume years
            TRUE                 ~ NA_real_)) # any other circumstance, assign missing
```

The criteria are applied in the order the `case_when()` statement is written. So if the criteria is met by the first argument (here, `age_unit` == "years"), then the remaining criteria are not tested. It is therefore important to order your arguments correctly, as in when writing a pipe chain `%>%`, from most specific to generic.

Along those lines, in your final statement, place TRUE on the left-side, which will capture any row that did not meet any of the previous criteria. The right-side of this statement could be assigned a value like “check me!” or missing.

DANGER: Values on the right-side must all be the same class - either numeric, character, date, logical, etc. To assign missing (NA), you may need to use special variations of NA such as NA_character_, NA_real_ (for numeric or POSIX), and as.Date(NA). Read more in Working with dates.

Here we want to look at the temperatures of people recorded in the dataset. However, upon first visualization we can see that there is some discordence in the dataset.

```{r, echo = F, eval = T, error = FALSE}
ggplot(data = linelist_raw) +
    geom_histogram(aes(x = temp), binwidth = 1) +
  scale_x_continuous(limits = c(30, 110), breaks = seq(30, 110, by = 10)) +
      labs(x = "Temperature", y = "Count")
```

Most of the values are located between 35 and 41, as expected if we were recording temperatures in °C, however some values are around 100, and so we can deduce that these have been incorrectly recorded in °F. Using the formula, `°C = (°F − 32) * 5/9`, can you use complex logic to convert values that are above 90 and below 120 to Celcius?

```{r temp_convert_logic, exercise = TRUE}
linelist %>%
  mutate()
```

```{r temp_convert_logic-hint}
You will need to use case_when and greater than (temp >) and less than (temp <) combined with the and (&)
```

```{r temp_convert_logic-check}
grade_result(
  pass_if(~ identical(.result, linelist %>%
    mutate(temp = case_when(temp > 90 & temp < 120 ~ (temp - 32) * 5/9,
                            TRUE ~ temp))), "You've successfully used complex logic, great work.")
)
```

### Missing values

Missing values are an ever present facet of dealing with real world data, and it is important to correctly identify and handle them in order to highlight data gaps and adjust our analysis accordingly. There are several inbuilt functions for dealing with missing data, depending on the scenario and the class of data.

To change missing values (`NA`) to a specific value, such as "Missing", we can use the **dplyr** function `replace_na()` with `mutate()`

```{r}
linelist <- linelist %>% 
  mutate(hospital = replace_na(hospital, "Missing"))
```

Factors are R’s way to handle ordered values such as c("First", "Second", "Third") or to set the order that values (e.g. hospitals) appear in tables and plots.

If your data are class Factor and you try to convert NA to “Missing” by using `replace_na()`, you will get this error: invalid factor level, NA generated. You have tried to add “Missing” as a value, when it was not defined as a possible level of the factor, and it was rejected.

The easiest way to solve this is to use the **forcats** function `fct_explicit_na()` which converts a column to class factor, and converts NA values to the character “(Missing)”.

```{r}
linelist %>% 
  mutate(hospital = fct_explicit_na(hospital))
```

To convert a specific value to NA, use **dplyr**’s `na_if()`. The command below performs the opposite operation of `replace_na()`. In the example below, any values of “Missing” in the column hospital are converted to NA.

```{r}
linelist <- linelist %>% 
  mutate(hospital = na_if(hospital, "Missing"))
```

However, `na_if()` cannot be used for logical criteria (e.g. “all values > 99”) - use `replace()` or `case_when()` for this:

```{r}
# Convert temperatures above 40 to NA 
linelist <- linelist %>% 
  mutate(temp = replace(temp, temp > 40, NA))

# Convert onset dates earlier than 1 Jan 2000 to missing
linelist <- linelist %>% 
  mutate(date_onset = replace(date_onset, date_onset > as.Date("2000-01-01"), NA))
```

We are now going to practice these different methods of replacing NA values. In `linelist` can you do the following:

* Convert NA values in the `age` column to ]"Age not recorded"
* If values in `bmi` are below 10 or above 40, replace them with NA

```{r NA_practice, exercise = TRUE}

```

```{r NA_practice-hint}
You will need to use both na_if() and replace(), and a few logical operators ("|", "<", ">")
```

```{r NA_practice-check}
grade_result(
  pass_if(~ identical(.result, linelist %>%
 mutate(age = na_if(age, "Age not recorded"),
        bmi = replace(bmi, bmi < 10 | bmi > 40, NA))), "You've successfully recoded NA values and used complex logic.")
)
```


### Cleaning dictionary

Use the R package **linelist** and it’s function `clean_variable_spelling()` to clean a data frame with a cleaning dictionary. **linelist** is a package developed by RECON - the R Epidemics Consortium.

1) Create a cleaning dictionary with 3 columns:
* “from” column (the incorrect value)
* A “to” column (the correct value)
* A column specifying the column for the changes to be applied (or “.global” to apply to all columns)

2) Import the dictionary file into R
`cleaning_dictionary <- import(cleaning_dictionary.csv)`

3) Pass the rawlinelist to `clean_variable_spelling()`, specifiying to `wordlists = ` the cleaning dictionary dataframe. The `spelling_vars` argument can be used to specify which column in the dictionary refers to the columns (3rd by default), or can be set to `NULL` in order to have the dictionary apply to all character and factor columns. Note this function can take a long time to run.

```{r, echo = T, eval = F}
linelist <- linelist %>% 
  linelist::clean_variable_spelling(
    wordlists = cleaning_dict,
    spelling_vars = "col",        # dictionary column containing column names
  )
```

## Numerical categories

There are numerous reasons why you may want to categorise numeric values, such as for age groups, lab values etc. R has several ways of doing this.

* `age_categories()`, from the **epikit** package
* `cut()` from base R
* `case_when()`
* quantile breaks with `quantile()` and `ntile()`

### age_categories()

With the **epikit** package, you can use the age_categories() function to easily categorize and label numeric columns (note: this function can be applied to non-age numeric variables too). As a bonus, the output column is automatically an ordered factor.

Here are the required inputs:

* A numeric vector (column)
* The `breakers = ` argument, provide a numeric vector of break points for new groups.

For example

```{r, echo = T, eval = T}
linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(             # create new column
      age_years,                            # numeric column to make groups from
      breakers = c(0, 5, 10, 15, 20,        # break points
                   30, 40, 50, 60, 70)))

# Display the table
table(linelist$age_cat, useNA = "always")
```

Break values specified are by default the lower bounds, here the categorisation occurs so that the left/lower side is "open" and "inclusive". . You can adjust how the labels are displayed with `separator = `, with the default as "-". 

You may also want to set an upper limit, this will categorise any value above the last breaker as `NA`. This is doing using `ceiling = TRUE`.

```{r, echo = T, eval = T}
linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(             # create new column
      age_years,                            # numeric column to make groups from
      breakers = c(0, 5, 10, 15, 20,        # break points
                   30, 40, 50, 60, 70),
      ceiling = TRUE))

# Display the table
table(linelist$age_cat, useNA = "always")
```

Alternatively, instead of using `breakers = ` you can provide `lower = `, `upper = ` and `by = `:

```{r, echo = T, eval = T}
linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(             # create new column
      age_years,                            # numeric column to make groups from
      lower = 0,
      upper = 70,
      by = 5))

# Display the table
table(linelist$age_cat, useNA = "always")
```

```{r quiz5}
quiz(
  question("Which of these age_categories() specifications would create breaks at 0, 25, 50 and 75?",
    answer("age_categories(age_years, breakers = c(0, 25, 50, 75))", correct = TRUE),
    answer("age_categories(age_years, lower = 0, upper = 75, by = 5)", correct = TRUE),
    answer("age_categories(age_years, breakers = c(0, 25, 50, 75), ceiling = FALSE", correct = TRUE),
    answer("age_categories(age_years, breakers = 25, lower = 0, upper  = 75)")
  ))
```

### cut()

`cut()` is a **base** R alternative to `age_categories()`. The basic syntax is to first provide a numeric culumn to be cut (`age_years`), and then the `breaks = ` argument which is a numeric vector `c()` of break points. 

By default, the categorisation occurs so the right/upper side is "open" and "inclusive", *this is the opposite behavior to `age_categories()` function*. You can reverse this behavior, and so align it with the `age_categories()` function through adding the `right = TRUE` argument.

Thus, by default, “0” values are excluded from the lowest group, and categorized as NA! “0” values could be infants coded as age 0 so be careful! To change this, add the argument `include.lowest = TRUE` so that any “0” values will be included in the lowest group. The automatically-generated label for the lowest category will then be “[A],B]”. Note that if you include the `include.lowest = TRUE` argument *and* `right = TRUE`, the extreme inclusion will now apply to the highest break point value and category, not the lowest.

```{r}
# Create new variable, by cutting the numeric age variable
# lower break is excluded but upper break is included in each category
linelist <- linelist %>% 
  mutate(
    age_cat = cut(
      age_years,
      breaks = c(0, 5, 10, 15, 20,
                 30, 50, 70, 100),
      include.lowest = TRUE         # include 0 in lowest group
      ))

# tabulate the number of observations per group
table(linelist$age_cat, useNA = "always")
```

**It is very important to check your work here, do so by cross-tabulating the numeric and category columns**
```{r}
# Cross tabulation of the numeric and category columns. 
table("Numeric Values" = linelist$age_years,   # names specified in table for clarity.
      "Categories"     = linelist$age_cat,
      useNA = "always") %>% # don't forget to examine NA values
  head()
```

**Re-labeling NA values**

You may want to assign NA values a label such as “Missing”. Because the new column is class Factor (restricted values), you cannot simply mutate it with `replace_na()`, as this value will be rejected. Instead, use `fct_explicit_na()` from the **forcats** package, as explained in the Factors page.

```{r}
linelist <- linelist %>% 
  
  # cut() creates age_cat, automatically of class Factor      
  mutate(age_cat = cut(
    age_years,
    breaks = c(0, 5, 10, 15, 20, 30, 50, 70, 100),          
    right = FALSE,
    include.lowest = TRUE,        
    labels = c("0-4", "5-9", "10-14", "15-19", "20-29", "30-49", "50-69", "70-100")),
         
    # make missing values explicit
    age_cat = fct_explicit_na(
      age_cat,
      na_level = "Missing age")  # you can specify the label
  )    

# table to view counts
table(linelist$age_cat, useNA = "always")
```

Can you write some code to create a new column `temp_cat` to convert values in `temp` to the following categories:

* Less than 38 - "No fever"
* Greater than or equal to 38 & less than 39.4 - "Low grade fever"
* Greater than or equal to 39.4 - "High grade fever"

set the lower bound to 0, and then display only the columns `temp` and `temp_cat`?

```{r cut_temp, exercise = TRUE}

```

```{r cut_temp-hint}
You will need to use the function cut() and specify the correct breaks, and remember that cut() occurs on the right side, and age_categories() the left, so if you are using cut() you may also need to include the argument right = FALSE 
```

```{r cut_temp-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal()
    # Default to failing grade with feedback
    fail()
  })
```

```{r cut_temp-solution}
  linelist %>% 
  mutate(temp_cat = cut(
    temp,
    breaks = c(0, 38, 39.4, 45),          
    right = FALSE,
    labels = c("No fever", "Low grade fever", "High grade fever"))) %>%
  select(temp, temp_cat)
```

### Quantile breaks

Quantiles, or percentiles, typically refer to a value below which a proportion of values fall. For example, the 95th percentile of ages in `linelist` would be the age below which 95% of the ages fall. 

However in common speech, “quartiles” and “deciles” can also refer to the groups of data as equally divided into 4, or 10 groups (note there will be one more break point than group).

To get quantile break points, you can use quantile() from the **stats** package from base R. You provide a numeric vector (e.g. a column in a dataset) and vector of numeric probability values ranging from 0 to 1.0. The break points are returned as a numeric vector. Explore the details of the statistical methodologies by entering ?quantile.

* If your input numeric vector has any missing values it is best to set na.rm = TRUE
* Set names = FALSE to get an un-named numeric vector

``` {r}
quantile(linelist$age_years,               # specify numeric vector to work on
  probs = c(0, .25, .50, .75, .90, .95),   # specify the percentiles you want
  na.rm = TRUE)                            # ignore missing values 
```

You can use the results of `quantile()` as break points in `age_categories()` or `cut()`. Below we create a new column deciles using `cut()` where the breaks are defined using `quantiles()` on age_years. Below, we display the results using `tabyl()` from janitor so you can see the percentages (see the Descriptive tables page). Note how they are not exactly 10% in each group.

```{r}
linelist %>%                                # begin with linelist
  mutate(deciles = cut(age_years,           # create new column decile as cut() on column age_years
    breaks = quantile(                      # define cut breaks using quantile()
      age_years,                               # operate on age_years
      probs = seq(0, 1, by = 0.1),             # 0.0 to 1.0 by 0.1
      na.rm = TRUE),                           # ignore missing values
    include.lowest = TRUE)) %>%             # for cut() include age 0
  janitor::tabyl(deciles)                   # pipe to table to display
```

### Evenly sized groups

Another tool to make numeric groups is the **dplyr** function `ntile()` which breaks your data into evenly sized groups - *be aware that unlike in `quantile()` the same value could appear in more than one group.* Firstly you provided the numeric vector (the column) and the number of groups with the values in the new column created being the group "numbers" not the range of values themselves (as when you use `cut()`).

```{r, echo = T, eval = T}
# make groups with ntile()
ntile_data <- linelist %>% 
  mutate(even_groups = ntile(age_years, 10))

# make table of counts and proportions by group
ntile_table <- ntile_data %>% 
  janitor::tabyl(even_groups)
  
# attach min/max values to demonstrate ranges
ntile_ranges <- ntile_data %>% 
  group_by(even_groups) %>% 
  summarise(
    min = min(age_years, na.rm=T),
    max = max(age_years, na.rm=T)
  )

# combine and print - note that values are present in multiple groups
left_join(ntile_table, ntile_ranges, by = "even_groups")

```

### Add to the pipe chain

Now we'll add some of this to the cleaning pipe chain so you can see how all the steps we have learned so far are coming together to create one cleaning pipeline!

```{r}
# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)
##################################################################################

# begin cleaning pipe chain
###########################
linelist <- linelist_raw %>%
    
    # standardize column name syntax
    janitor::clean_names() %>% 
    
    # manually re-name columns
           # NEW name             # OLD name
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # remove column
    select(-c(row_num, merged_header, x28)) %>% 
  
    # de-duplicate
    distinct() %>% 

    # add column
    mutate(bmi = wt_kg / (ht_cm/100)^2) %>%     

    # convert class of columns
    mutate(across(contains("date"), as.Date), 
           generation = as.numeric(generation),
           age        = as.numeric(age)) %>% 
    
    # add column: delay to hospitalisation
    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% 
    
    # clean values of hospital column
    mutate(hospital = recode(hospital,
                      # OLD = NEW
                      "Mitylira Hopital"  = "Military Hospital",
                      "Mitylira Hospital" = "Military Hospital",
                      "Military Hopital"  = "Military Hospital",
                      "Port Hopital"      = "Port Hospital",
                      "Central Hopital"   = "Central Hospital",
                      "other"             = "Other",
                      "St. Marks Maternity Hopital (SMMH)" = "St. Mark's Maternity Hospital (SMMH)"
                      )) %>% 
    
    mutate(hospital = replace_na(hospital, "Missing")) %>% 

    # create age_years column (from age and age_unit)
    mutate(age_years = case_when(
          age_unit == "years" ~ age,
          age_unit == "months" ~ age/12,
          is.na(age_unit) ~ age,
          TRUE ~ NA_real_)) %>% 
  
    # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED
    ###################################################   
    mutate(
          # age categories: custom
          age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)),
        
          # age categories: 0 to 85 by 5s
          age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5)))
```

## Adding rows

Adding rows one-by-one manually is tedious but can be done with `add_row()` from **dplyr**. Remember that each column must contain values of only one class (either character, numeric, logical, etc.). So adding a row requires nuance to maintain this.

```{r}
linelist <- linelist %>% 
  add_row(case_id = "abc",
          generation = 4,
          date_infection = as.Date("2020-10-10"),
          .before = 2)
```

Use `.before` and `.after`. to specify the placement of the row you want to add. `.before = 3` will put the new row before the current 3rd row. The default behavior is to add the row to the end. Columns not specified will be left empty (`NA`).

The new row number may look strange (“…23”) but the row numbers in the pre-existing rows have changed. So if using the command twice, examine/test the insertion carefully.

If a class you provide is off you will see an error like this:
`Error: Can't combine ..1$infection date <date> and ..2$infection date <character>.`

*(when inserting a row with a date value, remember to wrap the date in the function as.Date() like as.Date("2020-10-10")).*

**Bind rows**

To combine datasets together by binding the rows of one dataframe to the bottom of another data frame, you can use `bind_rows()` from **dplyr**. This is explained in more detail in the page Joining data.

## Filter rows

A typical cleaning step after cleaning columns and recoding values is to filter the dataset to specific rows with the **dplyr** function `filter()`.

### Simple filter

The simplest way of filtering, is to use a logical condition ("==", "!=", ">", "<", etc), so that only rows where the logical statement is `TRUE` are kept. For example here, we are only keeping rows where the gender is equal to "f".

```{r}
nrow(linelist)

linelist %>% 
  filter(gender == "f") %>%
  nrow()
```

From the reduction in rows you can see that we have subset the dataset.

### Filter out missing values

A common use of filtering is to remove rows that have missing values. This can either be done for any missing values in _any_ column, by not specifiying any arguments in the **tidyr** function `drop_na()`, or specific columns by including them within `drop_na()`.

```{r}
linelist %>% 
  drop_na(case_id, age_years)  # drop rows with missing values for case_id or age_years
```

Can you now write a pipe chain to filter out any rows with a `bmi` of more than 20, and then drop any rows that have NA values in any column between fever and vomit, and then show the first 6 rows with `head()`?

```{r filter_row_first, exercise = TRUE}

```

```{r filter_row_first-hint}
Remember to use logical operators, and that you can specify a group of consective columns with ":".
```

```{r filter_row_first-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal()
    # Default to failing grade with feedback
    fail()
  })
```

```{r filter_row_first-solution}
  linelist %>% 
  filter(bmi < 20) %>%
  drop_na(fever:vomit) %>%
  head()
```

### Filter by row number

You can also filter by row number, this is done using the **dplyr** function `row_number()`. Here you will often use the operator `%in%` to specify all numbers within a supplied vector. For instance

```{r}
# View first 100 rows
linelist %>% head(100)     # or use tail() to see the n last rows

# Show row 5 only
linelist %>% filter(row_number() == 5)

# View rows 2 through 20, and three specific columns
linelist %>% filter(row_number() %in% 2:20) %>% select(date_onset, outcome, age)
```


### Standalone

You can also use the filter function as part of a standalone command (not part of a pipe chain), as in all other **dplyr** functions the first argument must be the dataset itself. Here we show how to remove `NA` values:

```{r}
# dataframe <- filter(dataframe, condition(s) for rows to keep)
linelist <- filter(linelist, !is.na(case_id)) 
```

and this can also be done in base R

```{r}
# dataframe <- dataframe[row conditions, column conditions] (blank means keep all)
linelist <- linelist[!is.na(linelist$case_id), ]
```

## Row-wise calculations

We may want to perform a calculation within a row, and to do so we can use `rowwise()` from **dplyr**. 

For example, this code applies `rowwise()` and then creates a new column that sums the number of the specified symptom columns that have value “yes”, for each row in the linelist. The columns are specified within sum() by name within a vector `c()`. `rowwise()` is essentially a special kind of `group_by()`, so it is best to use `ungroup()` when you are done.

```{r}
linelist %>%
  rowwise() %>%
  mutate(num_symptoms = sum(c(fever, chills, cough, aches, vomit) == "yes")) %>% 
  ungroup() %>% 
  select(fever, chills, cough, aches, vomit, num_symptoms) # for display

```

As you specify the column to evaluate, you may want to use the “tidyselect” helper functions.

For example, the following code:

* Applies `rowwise()` so the following operation (`sum()`) is applied within each row (not summing entire columns)
* Creates new column num_NA_dates, defined for each row as the number of columns (with name containing “date”) for which `is.na()` evaluated to TRUE (they are missing data).
* `ungroup()` to remove the effects of `rowwise()` for subsequent steps

You could also provide other functions, such as max() to get the latest or most recent date for each row:

```{r}
linelist %>%
  rowwise() %>%
  mutate(latest_date = max(c_across(contains("date")), na.rm=T)) %>% 
  ungroup() %>% 
  select(latest_date, contains("date"))  # for display
```

## Arrange and sort

The **dplyr** function `arrange()` allows us to sort or order rows by column values. List the columns in the order they should be sorted on, and specify `.by_group = TRUE` if you want the sorting to occur by any groupings in the data.

By default the column will be sorted in "ascending" order, but you can change this to "descending" by wrapping it with `desc()`.

Sorting data with `arrange()` is particularly useful when making Tables for presentation, using `slice()` to take the “top” rows per group, or setting factor level order by order of appearance.

For example, to sort the our linelist rows by hospital, then by `date_onset` in descending order, we would use:

```{r}
linelist %>% 
   arrange(hospital, desc(date_onset)) %>%
   select(case_id, hospital, date_onset)
```

## Dates

Working with dates in R requires more attention than any other object class.  Below, we offer some tools and example to make this process less painful. Luckily, dates can be wrangled easily with practice, and with a set of helpful packages such as lubridate.

Upon import of raw data, R often interprets dates as character objects - this means they cannot be used for general date operations such as making time series and calculating time intervals. To make matters more difficult, there are many ways a date can be formatted and you must help R know which part of a date represents what (month, day, hour, etc.).

Dates in R are their own class of object - the Date class. It should be noted that there is also a class that stores objects with date and time. Date time objects are formally referred to as `POSIXt`, `POSIXct`, and/or `POSIXlt` classes (the difference isn’t important). These objects are informally referred to as datetime classes.

* It is important to make R recognize when a column contains dates.
* Dates are an object class and can be tricky to work with.
* Here we present several ways to convert date columns to Date class.

## Current date

To get the current "system" date you using `Sys.Date()`, and to get the time, `Sys.time()`. Alternatively you can return the date with `today()` and the time with `now()` from the **lubridate** package.

## Converting to a date

After importing a dataset into R, date column values may look like "1989/12/30", "05/06/2014" or "13 Jan 2020". In all these cases, R is likely still treating these as character values. *R must be told that these are dates, and the format that the dates are in (which is Day, Month and Year).* 

By default, the values of class Date are displayed as YYYY-MM-DD, later in this section we will discuss how tho change these.

### Base R

`as.Date()` is the base R function to convert an object or column to class Date. This requires:

* You specifiy the existing format of the raw character date
* If used on a character column all values must have the same exact format (if this is not the case try `guess_dates()` from the **linelist** package)

*First*, check the class of your column with `class()` from base R.
*Second*, within the `as.Date()` function, use the `format = ` argument to tell R the current format of the character date.

```{r, echo = T, eval = F}
# Convert to class date
linelist <- linelist %>% 
  mutate(date_onset = as.Date(date_onset, format = "%d/%m/%Y"))
```

Most of the strptime abbreviations are listed below. You can see the complete list by running ?strptime.

%d = Day number of month (5, 17, 28, etc.)
%j = Day number of the year (Julian day 001-366)
%a = Abbreviated weekday (Mon, Tue, Wed, etc.)
%A = Full weekday (Monday, Tuesday, etc.) %w = Weekday number (0-6, Sunday is 0)
%u = Weekday number (1-7, Monday is 1)
%W = Week number (00-53, Monday is week start)
%U = Week number (01-53, Sunday is week start)
%m = Month number (e.g. 01, 02, 03, 04)
%b = Abbreviated month (Jan, Feb, etc.)
%B = Full month (January, February, etc.)
%y = 2-digit year (e.g. 89)
%Y = 4-digit year (e.g. 1989)
%h = hours (24-hr clock)
%m = minutes
%s = seconds %z = offset from GMT
%Z = Time zone (character)

*Remember that you need to also get the date separator (/, -, space etc) correct in order to convert your dates*

### lubridate

The **lubridate** package makes handling dates and times a lot easier than using base R, and is recommended whenever you are working with dates

**lubridate* has several helper functions designed to convert character objects to dates in a more intuitive and lenient way. These functions are specific to the rough date format, but allow for a variety of separators, and synonyms for dates (e.g. 01 vs Jan vs January) - they are named after abbreviations of date formats.

The `ymd()` function converts date values supplied as year, month, day.
`r ymd("2020-10-11)`
`r ymd("20201011)`
The `mdy()` does the same but in the order of month, day, year.
`r mdy("Oct 11 20")`
and the `dmy()` in the format as day, month , year
`r dmy("11 October 2020")`

Within a pipe chain, it may look like this

```{r}
linelist <- linelist %>%
  mutate(date_onset = lubridate::dmy(date_onset))
```

You can then check the conversion has applied correctly by using `class()`.

Note that the above functions work best with 4-digit years. 2-digit years can produce unexpected results, as lubridate attempts to guess the century.

To convert a 2-digit year into a 4-digit year (all in the same century) you can convert to class character and then combine the existing digits with a pre-fix using str_glue() from the **stringr** package (see Characters and strings). Then convert to date.

```{r}
two_digit_years <- c("15", "15", "16", "17")
str_glue("20{two_digit_years}")
```

How would you use to convert all columns that containe `date_` to a year, month, day Date class?

```{r date_first, exercise = TRUE}

```

```{r date_first-hint}
A more compact way of doing this would be to use a tidyselect helper function such as across(). See earlier exercises where we converted columns to as.Character().
```

```{r date_first-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal()
    # Default to failing grade with feedback
    fail()
  })
```

```{r date_first-solution}
linelist %>%
  mutate(across(.cols = contains("date_"), .fns = lubridate::ymd))
```

### Combine columns

You can use the **lubridate** functions `make_date()` and `make_datetime()` to combine multiple numeric columns in one date column. For example, if you have the numeric columns `onset_day`, `onset_month` and `onset_year` in the dataframe `linelist`

```{r}
linelist <- linelist %>% 
  mutate(onset_date = make_date(year = onset_year, month = onset_month, day = onset_day))
```

## Excel dates

In the background, most software store dates as numbers. R stores dates from an origin of 1st January, 1970. Thus, if you run `as.numeric(as.Date("1970-01-01))` you will get `0`. 

Microsoft Excel stores dates with an origin of either December 30, 1899 (Windows) or January 1, 1904 (Mac), depending on your operating system. See this Microsoft guidance for more information.

Excel dates often import into R as these numeric values instead of as characters. If the dataset you imported from Excel shows dates as numbers or characters like “41369”… use `as.Date()` (or **lubridate**’s `as_date()` function) to convert, but instead of supplying a “format” as above, supply the Excel origin date to the argument `origin =.`

This will not work if the Excel date is stored in R as a character type, so be sure to ensure the number is class Numeric!

NOTE: You should provide the origin date in R’s default date format (“YYYY-MM-DD”).

```{r}
# An example of providing the Excel 'origin date' when converting Excel number dates
data_cleaned <- data %>% 
  mutate(date_onset = as.numeric(date_onset)) %>%   # ensure class is numeric
  mutate(date_onset = as.Date(date_onset, origin = "1899-12-30")) # convert to date using Excel origin
```

## Messy dates

Often dates are in a variety of different formats, the function `guess_dates()` from the **linelist** package attempts to read these and convert them to a standard format.

For example `guess_dates()` would see a vector of the following character dates “03 Jan 2018”, “07/03/1982”, and “08/20/85” and convert them to class Date as: `2018-01-03`, `1982-03-07`, and `1985-08-20`.

```{r}
linelist::guess_dates(c("03 Jan 2018",
                        "07/03/1982",
                        "08/20/85"))
```

## Working with the date-time class

Converting columns to the date-time class follows a similar format to the date class with **lubridate** functions, only with `_h` (only hours supplied), `_hm` (hours and minutes supplied), or `_hms` (hours, minutes, and seconds supplied) appended to the end (e.g. `dmy_hms()`).

`r ymd_h("2020-01-01 16hrs")`
`r ymd_h("2020-01-01 4PM")`
`r dmy_hm("01 January 2020 16:20")`
`r mdy_hms("01 January 2020, 16:20:40")`

When working with a data frame, time and date columns can be combined to create a datetime column using `str_glue()` from **stringr** package and an appropriate **lubridate** function.

In this example, the linelist data frame has a column in format “hours:minutes”. To convert this to a datetime we follow a few steps:

* Create a “clean” time of admission column with missing values filled-in with the column median. We do this because lubridate won’t operate on missing values. 
* Combine it with the column date_hospitalisation, and then use the function ymd_hm() to convert.

```{r}
# time_admission is a column in hours:minutes
linelist <- linelist %>%
  
  # when time of admission is not given, assign the median admission time
  mutate(
    time_admission_clean = ifelse(
      is.na(time_admission),         # if time is missing
      median(time_admission),        # assign the median
      time_admission                 # if not missing keep as is
  )) %>%
  
    # use str_glue() to combine date and time columns to create one character column
    # and then use ymd_hm() to convert it to datetime
  mutate(
    date_time_of_admission = str_glue("{date_hospitalisation} {time_admission_clean}") %>% 
      ymd_hm()
  )
```

### Convert times alone

If your data only contains character time (hours, minutes, seconds), you can convert and manipulate these as times using `strptime()` from base R. For example, to get the difference between these two times:

```{r}
# raw character times
time1 <- "13:45" 
time2 <- "15:20"

# Times converted to a datetime class
time1_clean <- strptime(time1, format = "%H:%M")
time2_clean <- strptime(time2, format = "%H:%M")

# Difference is of class "difftime" by default, here converted to numeric hours 
as.numeric(time2_clean - time1_clean)   # difference in hours
```

### Extract time

You can extract the elements of a time with `hour()`, `minute()` and `second()` from **lubridate**.

Here is an example of extracting the hour, and then classifing by part of the day. We begin with the column `time_admission`, which is class Character in format “HH:MM”. First, the `strptime()` is used as described above to convert the characters to datetime class. Then, the hour is extracted with `hour()`, returning a number from 0-24. Finally, a column time_period is created using logic with `case_when()` to classify rows into Morning/Afternoon/Evening/Night based on their hour of admission.

```{r}
linelist <- linelist %>%
  mutate(hour_admit = hour(strptime(time_admission, format = "%H:%M"))) %>%
  mutate(time_period = case_when(
    hour_admit > 06 & hour_admit < 12 ~ "Morning",
    hour_admit >= 12 & hour_admit < 17 ~ "Afternoon",
    hour_admit >= 17 & hour_admit < 21 ~ "Evening",
    hour_admit >=21 | hour_admit <= 6 ~ "Night"))
```

### Practice

```{r quiz5}
quiz(
  question("Which of the following functions would convert 'Jan 5 1997' to the correct Date format?",
    answer(mdy('Jan 5 1997'), correct = T),
    answer(guess_dates('Jan 5 1997'), correct = T),
    answer(as.Date('Jan 5 1997', format = "%b %d %Y"), correct = T),
  correct = "Yes, all of these work to convert your date! However, there is a lot more to specify in the base R function as.Date()"),
  question("Which of the following functions be used to convert a column that has the format year, month, day, hour, minute?",
    answer(ymd_hm(), correct = T),
    answer(ymd_hms(), correct = F),
    answer(mdy_hm(), correct = F),
  correct = "Correct, good work"))
```

We want to estimate the time from infection to onset. In order to do this, can you convert the columns `date_infection` and `date_onset` to Date objects, and then subtract `date_infection` from `date_onset` to create a new column, `time_to_symptoms`, and display only this column?

```{r date_convert_subtract, exercise = TRUE}

```

```{r date_convert_subtract-hint}
After converting the values from character class to Date, you can simply subtract the columns within mutate
```

```{r date_convert_subtract-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal()
    # Default to failing grade with feedback
    fail()
  })
```

```{r date_convert_subtract-solution}
linelist <- linelist %>%
  mutate(date_infection = ymd(date_infection),
         date_onset = ymd(date_onset),
         time_to_symptoms = date_onset - date_infection) %>%
  select(time_to_symptoms)
```

## Working with dates

Once converted you can extract aspects such as the year, month, day, weekday, week etc.

`r month(Sys.Date())`
`r day(Sys.Date())`
`r wday(Sys.Date())`

You can also extract time components from a datetime object or column. This can be useful if you want to view the distribution of admission times.

`r hour(Sys.time())`
`r minute(Sys.time())`
`r second(Sys.time())`

### Date math

Date math is simple once you have converted the dates, to add on a certain number of days, weeks, months or years you can use the functions `days()`, `weeks()`, `months()`, `years()`.

`r Sys.Date() + days(3)`
`r Sys.Date() + months(3)`
`r Sys.Date() + years(3)`

and again the same for adding on time

`r Sys.time() + hours(3)`
`r Sys.time() + minutes(3)`
`r Sys.time() + seconds(3)`

### Date intervals

The differences between dates can be calculated by

* Ensuring both dates are of class dates
* Use subtraction to return the difftime difference between two dates
* If necessary, convert to numeric class to perform subsequent calculations

```{r}
output <- example_date - ymd("2020-02-20")
output    # print
```
```{r}
class(output)
```

To do subsequent operations on a “difftime”, convert it to numeric with `as.numeric()`.

This can all be brought together to work with data - for example:

```{r}
linelist_delay <- linelist %>%
  
  # convert date of onset from character to date objects by specifying ymd format
  mutate(date_onset = ymd(date_onset),
         date_hospitalisation = ymd(date_hospitalisation)) %>%
  
  # filter out all cases without onset in march
  filter(month(date_onset) == 3) %>%
    
  # find the difference in days between onset and hospitalisation
  mutate(days_onset_to_hosp = date_hospitalisation - date_onset)

# calculate the median number of days to hospitalisation for all cases where data are available
median(linelist_delay$days_onset_to_hosp, na.rm = T)
```

## Date display

Once dates are the correct class, you often want them to display differently, for example to display as “Monday 05 January” instead of “2018-01-05”. You may also want to adjust the display in order to then group rows by the date elements displayed - for example to group by month-year.

### `format()`

Adjust date display with the base R function format(). This function accepts a character string (in quotes) specifying the desired output format in the “%” strptime abbreviations (the same syntax as used in as.Date()). Below are most of the common abbreviations.

%d = Day number of month (5, 17, 28, etc.)
%j = Day number of the year (Julian day 001-366)
%a = Abbreviated weekday (Mon, Tue, Wed, etc.)
%A = Full weekday (Monday, Tuesday, etc.)
%w = Weekday number (0-6, Sunday is 0)
%u = Weekday number (1-7, Monday is 1)
%W = Week number (00-53, Monday is week start)
%U = Week number (01-53, Sunday is week start)
%m = Month number (e.g. 01, 02, 03, 04)
%b = Abbreviated month (Jan, Feb, etc.)
%B = Full month (January, February, etc.)
%y = 2-digit year (e.g. 89)
%Y = 4-digit year (e.g. 1989)
%h = hours (24-hr clock)
%m = minutes
%s = seconds
%z = offset from GMT
%Z = Time zone (character)

### Month-Year

To convert a Date column to Month-year format, we suggest you use the function `as.yearmon()` from the **zoo** package. This converts the date to class “yearmon” and retains the proper ordering. In contrast, using `format(column, "%Y %B")` will convert to class Character and will order the values alphabetically (incorrectly).

Below, a new column `yearmonth` is created from the column date_onset, using the `as.yearmon()` function. The default (correct) ordering of the resulting values are shown in the table.

```{r}
# create new column 
test_zoo <- linelist %>% 
     mutate(yearmonth = zoo::as.yearmon(date_onset))

# print table
table(test_zoo$yearmon)
```

In contrast, you can see how only using `format()` does achieve the desired display format, but not the correct ordering.

```{r}
# create new column
test_format <- linelist %>% 
     mutate(yearmonth = format(date_onset, "%b %Y"))

# print table
table(test_format$yearmon)
```

## Epidemiological weeks

**lubridate**

We generally recommend using the `floor_date()` function from **lubridate**, with the argument `unit = "week"`. This rounds the date down to the “start” of the week, as defined by the argument `week_start =`. The default week start is 1 (for Mondays) but you can specify any day of the week as the start (e.g. 7 for Sundays). `floor_date()` is versatile and can be used to round down to other time units by setting unit = to “second”, “minute”, “hour”, “day”, “month”, or “year".

Which of these uses of `floor_date()` will result in rounding the date to the start of the week as a Thursday?

```{quiz5}
quiz(
  question("Which of the following functions would convert 'Jan 5 1997' to the correct Date format?",
    answer(floor_date(dmy("14/02/2022"), unit = "week", week_start = 1), correct = F),
    answer(floor_date(dmy("14/02/2022"), unit = "week", week_start = 6), correct = F),
    answer(floor_date(dmy("14/02/2022"), unit = "week", week_start = 4), correct = T),
    answer(floor_date(dmy("14/02/2022"), unit = "day", week_start = 4), correct = F),
  incorrect = "Remember that 1 represents Monday and 7 represents Sunday and that our unit is week"))
```

The returned value is the start date of the week, in Date class. Date class is useful when plotting the data, as it will be easily recognized and ordered correctly by `ggplot()`.

If you are only interested in adjusting dates to display by week in a plot, see the section in this page on Date display. For example when plotting an epicurve you can format the date display by providing the desired `strptime` “%” nomenclature. For example, use “%Y-%W” or “%Y-%U” to return the year and week number (given Monday or Sunday week start, respectively).

### Weekly counts

For example, to work out the weekly cases we carry out the following operations:

1. Create a new ‘week’ column with `mutate()`, using `floor_date()` with `unit = "week"`
2. Get counts of rows (cases) per week with `count()`; filter out any cases with missing date
3. Finish with `complete()` from **tidyr** to ensure that all weeks appear in the data - even those with no rows/cases. By default the count values for any “new” rows are NA, but you can make them 0 with the `fill = argument`, which expects a named list (below, `n` is the name of the counts column).

```{r}
# Make aggregated dataset of weekly case counts
weekly_counts <- linelist %>% 
  drop_na(date_onset) %>%             # remove cases missing onset date
  mutate(weekly_cases = floor_date(   # make new column, week of onset
    date_onset,
    unit = "week")) %>%            
  count(weekly_cases) %>%           # group data by week and count rows per group (creates column 'n')
  tidyr::complete(                  # ensure all weeks are present, even those with no cases reported
    weekly_cases = seq.Date(          # re-define the "weekly_cases" column as a complete sequence,
      from = min(weekly_cases),       # from the minimum date
      to = max(weekly_cases),         # to the maxiumum date
      by = "week"),                   # by weeks
    fill = list(n = 0)) %>%             # fill-in NAs in the n counts column with 0
  head()                            #Display the top 6 entries
```

```{r quiz5}
quiz(
  question("What class does subtracting two dates create?",
           answer("Character"),
           answer("Date"),
           answer("Numeric"),
           answer("Difftime"), correct = T),
  question("What does floor_date() do?",
           answer("Converts a date-time object and rounds it down", correct = T),
           answer("Converts a date-time object and rounds it up"),
           answer("Converts a numeric object and rounds it down")))
```

### Epiweek alternatives

Note that **lubridate** also has functions `week()`, `epiweek()`, and `isoweek()`, each of which has slightly different start dates and other nuances. Generally speaking though, `floor_date()` should be all that you need. Read the details for these functions by entering ?week into the console.

Now imagine we want to create create a new variable, `week_of_infection`, that has the epiweek of `date_infection`. However, many of these dates are unknown (`NA` values). We had previously calculated the value `time_to_symptoms` by subtracting `date_infection` from `date_onset` and so we can use the median value of this to come up with a crude replacement for the date of infection.

Can you do the following:

1) Create a new column called `estimated_or_recorded` which if the value of `date_infection` is `NA` it will be "estimated" or "recorded" if it is not.
2) If the column `estimated_or_recorded` has the value "estimated", then we will use subtract the `median(time_to_symptoms)` from `date_onset` to fill in the NA value in a new column `date_infection_updated`
3) Convert `date_infection_updated` to the epiweek in a new column `week_infection`.

```{r epiweek_convert, exercise = TRUE}
linelist %>%
  drop_na(date_onset) %>%
  mutate(date_infection = ymd(date_infection),
         date_onset = ymd(date_onset),
         time_to_symptoms = as.numeric(date_onset - date_infection)) #Add in additonal arguments within this mutate
```

```{r epiweek_convert-hint}
You will want to use
```

```{r epiweek_convert-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal()
    # Default to failing grade with feedback
    fail()
  })
```

```{r epiweek_convert-solution}
linelist %>%
  drop_na(date_onset) %>%
  mutate(date_infection = ymd(date_infection),
         date_onset = ymd(date_onset),
         time_to_symptoms = as.numeric(date_onset - date_infection),
         estimated_or_recorded = if_else(
           is.na(date_infection),
           "estimated",
           "recorded"),
         date_infection_updated = if_else(
           estimated_or_recorded == "estimated",
           date_onset - days(median(time_to_symptoms, na.rm = T)),
           date_infection
         ),
         week_infection = epiweek(date_infection_updated))
```





You might consider using the package **aweek** to set epidemiological weeks. It has the functions `date2week()` and `week2date()` in which you can set the week start day with `week_start = "Monday"`. This package is easiest if you want “week”-style outputs (e.g. “2020-W12”). Another advantage of **aweek** is that when `date2week()` is applied to a date column, the returned column (week format) is automatically of class Factor and includes levels for all weeks in the time span (this avoids the extra step of `complete()` described above). However, **aweek** does not have the functionality to round dates to other time units such as months, years, etc.

## Converting date/time zones

When data is present in different time time zones, it can often be important to standardise this data in a unified time zone. This can present a further challenge, as the time zone component of data must be coded manually in most cases.

In R, each datetime object has a timezone component. By default, all datetime objects will carry the local time zone for the computer being used - this is generally specific to a location rather than a named timezone, as time zones will often change in locations due to daylight savings time. It is not possible to accurately compensate for time zones without a time component of a date, as the event a date column represents cannot be attributed to a specific time, and therefore time shifts measured in hours cannot be reasonably accounted for.

To deal with time zones, there are a number of helper functions in **lubridate** that can be used to change the time zone of a datetime object from the local time zone to a different time zone. Time zones are set by attributing a valid tz database time zone to the datetime object. A list of these can be found here - if the location you are using data from is not on this list, nearby large cities in the time zone are available and serve the same purpose.

https://en.wikipedia.org/wiki/List_of_tz_database_time_zones

```{r}
# assign the current time to a column
time_now <- Sys.time()
time_now

# use with_tz() to assign a new timezone to the column, while CHANGING the clock time
time_london_real <- with_tz(time_now, "Europe/London")

# use force_tz() to assign a new timezone to the column, while KEEPING the clock time
time_london_local <- force_tz(time_now, "Europe/London")

# note that as long as the computer that was used to run this code is NOT set to London time,
# there will be a difference in the times 
# (the number of hours difference from the computers time zone to london)
time_london_real - time_london_local

```

## Lagging and leading calculations

`lead()` and `lag()` are functions from **dplyr** which help find previous (lagged) or subsequent (leading) values in a vector. This is useful when doing calculations of change/difference between time units.

Let’s say you want to calculate the difference in cases between a current week and the previous one. The data are initially provided in weekly counts as shown below. When using lag() or lead() the order of rows in the dataframe is very important! - pay attention to whether your dates/numbers are ascending or descending

First, create a new column containing the value of the previous (lagged) week.

* Control the number of units back/forward with n = (must be a non-negative integer)
* Use default = to define the value placed in non-existing rows (e.g. the first row for which there is no lagged value). By default this is NA.
* Use order_by = TRUE if your the rows are not ordered by your reference column

```{r}
counts <- weekly_counts %>% 
  mutate(cases_prev_wk = lag(n, n = 1))
```

```{r}
counts %>% 
  mutate(cases_prev_wk = lag(n, n = 1),
         case_diff = n - cases_prev_wk) %>%
  head()
```



