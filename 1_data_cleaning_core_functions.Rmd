---
title: "Data cleaning"
output: 
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
description: >
  Learn how to get started with R and RStudio, and how to import a dataset
---

<!-- Add JavaScript code for making the exercise code larger -->
<script language="JavaScript" src="js/exercise-font-size.js"></script>

```{r setup, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE) 
# load packages ----------------------------------------------------------------
library(learnr)
library(gradethis)
library(tidyverse)
library(here)
library(janitor)
library(rio)
library(basket) # not sure if we need this
library(etude) # helper functions for gradethis
library(epikit)
library(linelist)
library(lubridate)
library(fastLink)
library(sortable)

# set options for exercises and checking ---------------------------------------
gradethis_setup()

learnr::tutorial_options(exercise.timelimit = 60) 
  #exercise.checker = gradethis::grade_learnr) 
    # alternatively, submitr::null_code_checker


# event recorder ---------------------------------------------------------------
# see https://github.com/dtkaplan/submitr/blob/master/R/make_a_recorder.R
tutorial_options(exercise.eval = FALSE)  # pre-evaluate exercises

vfun <- submitr::make_basic_validator(NULL, "hello") #basket::check_valid

new_recorder <- function(tutorial_id, tutorial_version, user_id, event, data) {
    cat(
      tutorial_id, 
      " (v", tutorial_version, "); ",
      format(Sys.time(), "%Y-%M%-%D %H:%M:%S %Z"), "; ",
      user_id, "; ",
      event, "; ",
      data$label, "; ",
      data$answers, "; ",
      data$code, "; ",
      data$correct, "\n", sep = "",
      
      file = here::here("event_records", "learnr_basics.txt"),
      append = TRUE)
}

options(tutorial.event_recorder = new_recorder)


# hide non-exercise code chunks ------------------------------------------------
knitr::opts_chunk$set(echo = FALSE)


# data prep --------------------------------------------------------------------
linelist_raw <- rio::import(here::here("data", "linelist_raw.xlsx"))
linelist <- rio::import(here::here("data", "linelist_cleaned.rds"))
malaria_counts <- rio::import(here::here("data", "malaria_facility_count_data.rds"))

#Incorrectly assign class so we can clean later
linelist_raw$age <- as.character(linelist_raw$age)
linelist_raw$`date onset` <- as.character(linelist_raw$`date onset`)

#Going to randomly convert some temperatures to Fahrenheit instead of celcius for an exercise later
set.seed(1)
take_these <- sample(1:nrow(linelist_raw), 500)

linelist_raw$temp[take_these] <- (linelist_raw$temp[take_these] * 9/5) + 32

#Create some dummy df's for pivoting exercises
df <- data.frame(id = c("A", "B", "C"),
           obs1_date = c("2021-04-23", "2021-04-23", "2021-04-23"),
           obs1_status = c("Healthy", "Healthy", "Missing"),
           obs2_date = c("2021-04-24", "2021-04-24", "2021-04-24"),
           obs2_status = c("Healthy", "Healthy", "Healthy"),
           obs3_date = c("2021-04-25", "2021-04-25", "2021-04-25"),
           obs3_status = c("Unwell", "Healthy", "Healthy"))

fever_followup <- data.frame(patient = 1:10,
                             observation1_date = Sys.Date() - 21,
                        observation2_date = Sys.Date() - 14,
                        observation3_date = Sys.Date() - 7,
                        observation1_temp = sample(seq(35, 45, by = 0.1), 10, replace = T),
                        observation2_temp = sample(seq(35, 45, by = 0.1), 10, replace = T),
                        observation3_temp = sample(seq(35, 45, by = 0.1), 10, replace = T))

fever_followup$observation1_fever <- ifelse(fever_followup$observation1_date < 38, "No fever",
                              ifelse(fever_followup$observation1_date >= 38 & fever_followup$observation1_date< 39.4, "Mild fever",
                                     ifelse(fever_followup$observation1_date >= 39.4, "High fever", NA)))
fever_followup$observation2_fever <- ifelse(fever_followup$observation2_date < 38, "No fever",
                              ifelse(fever_followup$observation2_date >= 38 & fever_followup$observation2_date< 39.4, "Mild fever",
                                     ifelse(fever_followup$observation2_date >= 39.4, "High fever", NA)))
fever_followup$observation3_fever <- ifelse(fever_followup$observation3_date < 38, "No fever",
                              ifelse(fever_followup$observation3_date >= 38 & fever_followup$observation3_date< 39.4, "Mild fever",
                                     ifelse(fever_followup$observation3_date >= 39.4, "High fever", NA)))


fill_table_1 <- 
  tibble::tribble(
       ~Measurement, ~Facility, ~Cases,
                  1,  "Hosp 1",     66,
                  2,  "Hosp 1",     26,
                  3,  "Hosp 1",      8,
                  1,  "Hosp 2",     71,
                  2,  "Hosp 2",     62,
                  3,  "Hosp 2",     70,
                  1,  "Hosp 3",     47,
                  2,  "Hosp 3",     70,
                  3,  "Hosp 3",     38,
       )

fill_table_2 <- 
  tibble::tribble(
    ~Year, ~Measurement, ~Facility, ~Cases,
     2000,            1,  "Hosp 4",     82,
     2001,            2,  "Hosp 4",     87,
     2002,            3,  "Hosp 4",     46
  )

linelist_mini <- linelist %>%                 # start with original linelist
  select(case_id, date_onset, hospital) %>%   # select columns
  head(10)     

# Make the hospital information dataframe
hosp_info = data.frame(
  hosp_name     = c("central hospital", "military", "military", "port", "St. Mark's", "ignace", "sisters"),
  catchment_pop = c(1950280, 40500, 10000, 50280, 12000, 5000, 4200),
  level         = c("Tertiary", "Secondary", "Primary", "Secondary", "Secondary", "Primary", "Primary")
)

#Make some ID's and dataframes to join for exercises
patient_ID <- apply(sapply(1:10, function(x) sample(c(LETTERS, 0:9), 10, replace = T)), 2, paste0, collapse = "")


patient_symptoms <- data.frame(patient_id = sample(patient_ID, 10),
                  linelist %>%
    select(fever:vomit) %>%
    filter(row_number() %in% 1:10))

patient_dates <- data.frame(id = patient_ID,
                  linelist %>%
    select(contains("date")) %>%
    filter(row_number() %in% c(sample(which(is.na(linelist$date_onset)), 5),
  sample(which(!is.na(linelist$date_onset)), 5))))

#Probablistic matching

# make datasets

cases <- tribble(
  ~gender, ~first,      ~middle,     ~last,        ~yr,   ~mon, ~day, ~district,
  "M",     "Amir",      NA,          "Khan",       1989,  11,   22,   "River",
  "M",     "Anthony",   "B.",        "Smith",      1970, 09, 19,      "River", 
  "F",     "Marialisa", "Contreras", "Rodrigues",  1972, 04, 15,      "River",
  "F",     "Elizabeth", "Casteel",   "Chase",      1954, 03, 03,      "City",
  "M",     "Jose",      "Sanchez",   "Lopez",      1996, 01, 06,      "City",
  "F",     "Cassidy",   "Jones",      "Davis",     1980, 07, 20,      "City",
  "M",     "Michael",   "Murphy",     "O'Calaghan",1969, 04, 12,      "Rural", 
  "M",     "Oliver",    "Laurent",    "De Bordow" , 1971, 02, 04,     "River",
  "F",      "Blessing",  NA,          "Adebayo",   1955,  02, 14,     "Rural"
)

results <- tribble(
  ~gender,  ~first,     ~middle,     ~last,          ~yr, ~mon, ~day, ~district, ~result,
  "M",      "Amir",     NA,          "Khan",         1989, 11,   22,  "River", "positive",
  "M",      "Tony",   "B",         "Smith",          1970, 09,   19,  "River", "positive",
  "F",      "Maria",    "Contreras", "Rodriguez",    1972, 04,   15,  "Cty",   "negative",
  "F",      "Betty",    "Castel",   "Chase",        1954,  03,   30,  "City",  "positive",
  "F",      "Andrea",   NA,          "Kumaraswamy",  2001, 01,   05,  "Rural", "positive",      
  "F",      "Caroline", NA,          "Wang",         1988, 12,   11,  "Rural", "negative",
  "F",      "Trang",    NA,          "Nguyen",       1981, 06,   10,  "Rural", "positive",
  "M",      "Olivier" , "Laurent",   "De Bordeaux",  NA,   NA,   NA,  "River", "positive",
  "M",      "Mike",     "Murphy",    "O'Callaghan",  1969, 04,   12,  "Rural", "negative",
  "F",      "Cassidy",  "Jones",     "Davis",        1980, 07,   02,  "City",  "positive",
  "M",      "Mohammad", NA,          "Ali",          1942, 01,   17,  "City",  "negative",
  NA,       "Jose",     "Sanchez",   "Lopez",        1995, 01,   06,  "City",  "negative",
  "M",      "Abubakar", NA,          "Abullahi",     1960, 01,   01,  "River", "positive",
  "F",      "Maria",    "Salinas",   "Contreras",    1955, 03,   03,  "River", "positive"
  )


cases_dup <- rbind(cases,
                   data.frame(
                     gender = c("M", "F"),
           first = c("Tony", "Maria"),
           middle = c("B.", "Contreras"),
           last = c("Smith", "Rodriguez"),
           yr = c(1970, 1972),
           mon = c(9, 4),
           day = c(19, 15),
           district = c("River", "River"))
           )

#Create a  factor column
linelist$source[is.na(linelist$source)] <- "missing"
linelist$source <- factor(linelist$source)

```


```{r}
submitr::login_controls() # show login and password with "Submit" button.
```


```{r context = "server", echo = FALSE}
# see https://rdrr.io/github/dtkaplan/submitr/f/vignettes/using.Rmd
options(tutorial.storage = "none")
vfun <- submitr::make_basic_validator(NULL, "hello")       #basket::check_valid
storage_actions <- submitr::record_local("./minimal_submissions.csv")
submitr::shiny_logic(input, output, session, vfun,
                     storage_actions)
```




## Introduction to R for Applied Epidemiology and Public Health
### Data cleaning and core functions

```{r appliedepi-banner, fig.margin = TRUE, echo = FALSE, fig.width = 3, out.width = "100%", fig.cap = ""}
knitr::include_graphics("images/moz-banner.png")
```


### Welcome

Welcome to the course "Introduction to R for applied epidemiologists", offered for free by [Applied Epi](www.appliedepi.org) - a non-profit organisation that offers open-source tools, training, and support to frontline public health practitioners.

This interactive tutorial focuses on **cleaning of datasets often encountered by applied epidemiologists and public health practitioners**, such as outbreak linelists, surveillance, and laboratory data.  


#### Target Audience  

This course is designed with the following objectives: 

* To be friendly to people who have never used a programming language before
* To teach R emphasizing examples, datasets, and challenges commonly faced by applied epidemiologists
* To be modular - so that you can skip to section most relevant to you

If this is your first introduction to R programming, please consider first completing our [R Setup and Data Import tutorial], which introduces R, RStudio, R projects, R code syntax, and explains how to import a dataset into R.  



#### Other languages
This course is available...


#### Offline / Online

You can access this tutorial offline by downloading our R package ... 
If viewing offline, you can view the videos by doing ...



#### Learning goals

In this tutorial you will learn and practice:  

* Using the pipe operator (`%>%`) to pass the dataset from one cleaning function to another
* The core **tidyverse** R functions used to reduce, clean, and modify dataframes  
* How to manipulate dates in order to clean and translate between units of time (days/months/years) with the **lubridate** package
* The use of descriptive analysis and summary statistics with the **janitor** package in order to summarize your data



This tutorial adapts the [Data cleaning and core functions](https://epirhandbook.com/en/cleaning-data-and-core-functions.html) section of our free [ Epidemiologist R Handbook](https://epirhandbook.com/en/), which is available for use offline as well. 


#### Data consent

We continually improve these tutorials by collecting your entries and submitted answers to the quiz questions. By continuing, you consent to this collection and use.

To continue anonymously... do XYZ.



#### Who made this course  

This course is designed by epidemiologists with decades of ground-level experience in outbreak response and local public health work. 


```{r appliedepi-hexes, fig.margin = TRUE, echo = FALSE, fig.width = 3, out.width = "50%", fig.cap = ""}
knitr::include_graphics("images/hex-sidebyside.png")
```


## Data used and directory structure

In this tutorial we will use the following datasets. Please take a few minutes to review the structure and content of each dataset before continuing.

Use the arrows on the right to scroll through hidden columns. Note that these are "raw" (messy) datasets that mimic problems commonly found in real-life epidemiological datasets.  


### **A "linelist" of cases in a fictional (not real) Ebola outbreak**

A "linelist" is a term used in applied epidemiology to refer to a table that contains key information about each case or suspect case in an outbreak. Each row represents one case, and the columns contain variables such as age, sex, date of symptom onset, outcomes, etc.

This dataset contains `r nrow(linelist_raw)` rows and `r ncol(linelist_raw)` columns. Below are the first 5 rows:  

```{r}
head(linelist_raw)
```

Click to [download the **raw** dataset](https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_raw.xlsx) for your own practice.

Click to [download the **clean** dataset as an **.rds file**](https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds) for your own practice. A *.rds file* is an R-specific file type that preserves column classes. This ensures you will have only minimal cleaning to do after importing the data into R.

### **Aggregated data from malaria surveillance in a fictional country**  

Aggregated data in epidemiology usually means a table of counts for each facility, or district, etc. Sometimes, the counts can also be per day, week, or month.  

In this fictional dataset, each facility reported *daily* case counts of rapid-test (RDT)-confirmed malaria. Thus, each row represents the number of cases for a specific facility on a specific day.  

This dataset contains `r nrow(malaria_counts)` rows and `r ncol(malaria_counts)` columns. Below are the first 5 rows:  

```{r}
head(malaria_counts)
```


Click to [download the **clean** malaria counts dataset as an **.rds file**](https://github.com/appliedepi/epirhandbook_eng/raw/master/data/malaria_facility_count_data.rds) for your own practice. A *.rds file* is an R-specific file type that preserves column classes. This ensures you will have only minimal cleaning to do after importing the data into R.


### Directory structure

Photo or GIF of directory structure

### Accessing example data
Here is how to access the example data

### Tidy Data

We highly recommend doing our tutorial on Tidy Data in Applied Epidemiology. Collecting, formatting, and preparing your dataset *before* importing it into R is a critical step!
LINK
VIDEO TEASER




## Install and Load R packages {#packages}

To use basic functions with public health data, the tidyverse metapackage is very useful. Tidyverse loads the dplyr, ggplot2, and other packages that are useful in epi data analysis. 

We've preloaded the below packages for now. Installation and loading of these packages is described on the EpiRHandbook [_Suggested Packages_](https://epirhandbook.com/en/suggested-packages-1.html) page. 


In this assignment we'll work with X R packages, let's load them!

```{r load-package, exercise = TRUE}
pacman::p_load(___)
```

```{r load-package-hint}
pacman::p_load(rio, here, janitor, tidyverse)

```

```{r load-package-check}
grade_this_code("You are correct, the packages you need for this lesson are now loaded!")
```

```{r eval=FALSE}
pacman::p_load(learnr, here, rio, janitor, tidyverse)
```

### Recommended R packages for public health

See this Epi R Handbook LINK for our recommended packages.


## Import data {#import} 
https://www.epirhandbook.com/en/import-and-export.html
Import that data and save it as "raw" file

To import data from a sub-folder, the `import()` command should be modified so that it correctly tells R where to search for this file. This is done using the here() function. 

```{r import-demo-subfolder, echo=T, eval=F}
linelist_raw <- import(here("data", "linelist_raw.xlsx"))   # import data and save as named object
```


## Begin pipe chain
What is a pipe chain?
A pipe chain refers to the use of the "pipe" operator `%>%` to chain together operations (such as cleaning, reordering and manipulating) for altering a dataset. 

This allows us to carry out several different alterations of the dataframe in a single operation. It can be helpful to think of the pipe operator `%>%` as telling the computer "and then" between your operational commands. The order of this pipeline is important as operations occur sequentially, and so improperly ordered arguments may fail or (potentially more dangerously!) give incorrect values or unwanted outcomes.

Can you arrange the following commands from the **janitor** package, and **base** R, to clean the names of the dataset `linelist_raw`, select any columns that contain "_date" and display the names of these columns? Don't worry if you have not seen these functions before, we will explain them later.

```{r sortable_question, echo = FALSE}
function_order <- c("clean_names()", "select(contains('date'))", "names()")

# Initialize the question
question_rank(
  "Arrange these functions in order to clean, select all columns with date in the name, and then print these names:",
  answer(function_order, correct = TRUE),
  answer(rev(function_order), correct = FALSE, message = "Other direction!"),
  allow_retry = TRUE
)
```

This was a very simple example giving you a first taste of pipe operators and cleaning functions, as we progress through the chapter you will gain more familiarity with the functions available and how to use them in increasingly complex examples.

## Column names

In R, column names are the header, or top, value of a column and are used as the default value in figures. In other statistical software (such as SAS and STATA) "labels"  co-exist as longer printed versions of shorter column names, and while R can do this, it is not emphasized and for plotting and printing "friendly" column names, we generally adjust their display in the code to create the figure or tables.

As we call column names often, it is helpful to have a "clean" syntax. We suggest that they are:

*   Short
*   No spaces (replace with underscores)
*   No unusual characters (&, #, <, >, ...)
*   Similar style nomenclature (e.g. all date columns named like **date_**onset, **date_**report, **date_**death, ...)

These are often not what real, raw, data and linelists look like, luckily R has a set of very handy and easy to use tools to clean and standardize column names.

For example, if we look at the example linelist using the `names()` function:
```{r, echo = T, eval = T}
names(linelist_raw)
```
We can see that there are numerous violations of this clean syntax. We have names with spaces (infection date), different naming patterns for dates (date onset vs infection date) and there must have been a merged header across the last two columns (as the second last column i called "merged_header" and the last "...28" indicating it was assigned a placeholder name (it is the 28th column)). 

```{r rhetorical1, echo = FALSE}
question_text(
  "Can you think of a reason why it is useful to have a clean syntax for data organization and analysis?",
  answer_fn(function(value) {
    if (grepl(paste(letters, collapse = "|"), value)) {
      correct("")
    }
  }, )
)
```

### Automatic cleaning

Manually changing these column names to the preferred clean syntax would be time consuming, error prone and would need to be repeated everytime new versions of the linelist became available. Luckily, R has some helpful functions to make this process much faster and reproducible.

The first function we will explore in detail is the `clean_names()` function from the **janitor** package. This function does a lot of the hard work of cleaning column names for us. It does this through:

* Converting names to consist of only underscores, numbers and letters
* Accented characters are transliterated to ASCII (e.g. german o with umlaut becomes “o”, spanish “enye” becomes “n”)
* Capitalization preference for the new column names can be specified using the case = argument
* You can specify specific name replacements by providing a vector to the replace = argument (e.g. replace = c(onset = "date_of_onset"))

Here we can see the differences in the column names of the cleaned and uncleaned dataset.

```{r, echo = T, eval = T}
linelist_raw %>%                              #Define the dataset, and then
  names()                                     #Display the column names

linelist_raw %>%                              #Define the dataset, and then
         clean_names() %>%                    #clean the dataset columns, and then
         names()                              #Display the column names

```

You can see that this has done a lot of the work for us, replacing spaces with "_", and ensuring there are no unusual characters. However, if we want to standardize the entire dataset to the "clean syntax" described previously, we will have to include additional cleaning stages.

For example, if we wanted to use a similar style nomenclature such as **date_**, then we would have to carry out additional, manual, steps to the columns `infection_date`, `hosp_date`, `date_of_outcome`.

### Manual name cleaning

This manual name cleaning can be done through the function `rename()` from the **dplyr** package as part of a pipe chain. Here the function follows the syntax `NEW = OLD`. So to clean the linelist, rename the columns previously mentioned and then display the names, we would do the following:

```{r, echo = T, eval = T}
linelist_raw %>%
  clean_names() %>%
         #New name         #Old names
  rename(date_infection = infection_date,
         date_hospitalisation = hosp_date,
         date_outcome = date_of_outcome) %>%
  names()

```

As you can see, the column names have changed. You can also do this by column position, though this is less encouraged as column positions can easily change between datasets and versions. Here we are updating the names of column 1 and 2 to "id" and "gen"

```{r, echo = T, eval = T}
linelist_raw %>%
  clean_names() %>%
         #New name #Old names
  rename(id = 1,
         gen = 2) %>%
  names()
```


```{r quiz0}
quiz(
  question("What arguments would you specify to change the column name 'aches' to 'malaise'?",
    answer("rename(aches = malaise)"),
    answer("clean_names()"),
    answer("names(aches = malaise)"),
    answer("rename(malaise = aches)", correct = TRUE)
  )
)
```

### Select columns

Another way of re-naming columns is through the `select()` function. This function subsets your dataset, removing unwanted columns, and allowing you to rename the columns you have kept.

```{r, echo = T, eval = T}

linelist_raw %>%
  select(#New name #Old name
    date_infection = 'infection date',
    date_hospitalisation = 'hosp date')

```

As you can see, this has subset to the columns with the original names of `infection date` and `hosp date` and renamed them. Note, because of the spaces in the names of the dataset we need to put the column name within ' ' as R does not like spaces in column names.

`select()` can be used without renaming in order to subset a dataset to the columns you are interested in.

```{r, echo = T, eval = F}
linelist_raw %>%
  select(case_id, generation, gender)
```

Using what we have learned, can you `clean()`, `rename()`, `select()` and `head()` to recreate the output below?

```{r, eval = T}
  linelist_raw %>%                                        #Define the dataset, and then
         clean_names() %>%                              #clean the dataset columns, and then
                #New name   Old name
         rename(date_infection = infection_date,
                date_outcome = date_of_outcome) %>%     #rename the select columns, and then
         select(case_id, date_infection, date_outcome) %>%
         head()
```

```{r clean_rename_select, exercise = TRUE}

```

```{r clean_rename_select-hint}
Remember the order of your pipe chain is important.
```

```{r clean_rename_select-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal(message =  "Excellent, you have cleaned the dataset and subset to the columns you want")
    # Default to failing grade with feedback
    fail()
  })
```

```{r clean_rename_select-solution}
linelist_raw %>%
         clean_names() %>%
         rename(date_infection = infection_date,
                date_outcome = date_of_outcome) %>%
         select(case_id, date_infection, date_outcome) %>%
         head()
```

This gives you an insight into how to clean and subset a dataset, however when you have a large dataset manually specifiying columns can be cumbersome. Sometimes you want to extract columns with a specific prefix/suffix, or when they contain a certain word. 

Rather than manually typing these out, and especially if we have a cleaned dataset adhering to the "clean style" syntax specified previously, we can use "tidyselect" helper functions

### Tidyselect helper functions

Tidyselect helper functions are functions that work within **dplyr** functions such as `select()`, `across()` or `summarize()`. These offer convenient shortcuts for selecting subsets of columns that match specified criteria:

* `everything()` - all othecolumns not mentioned
* `last_col()` - the last column
* `where()` - applies a function to all columns and selects those which are true
  * example: `select(where(is.numeric))`
  * This would select all columns where the class is numeric
* `contains()` - columns containing a character string
  * example: `select(contains("time"))`
* `starts_with()` - matches to a specified prefix
  * example: `select(starts_with("date_"))`
* `ends_with()` - matches to a specified suffix
  * example: `select(ends_with("_post"))`
* `matches()` - to apply a regulaexpression (regex)
  * example: `select(matches("[pt]al))`
  * Regular expression (regex) refers to a sequence of characters that specifies a search pattern in text. If you are unfamiliawith regex, then there some aspects may seem non-intuitive, foa good introduction to the use of regex please see https://cran.r-project.org/web/packages/stringr/vignettes/regular-expressions.html.
* `num_range()` - a numerical range
  * example: `select(num_range("week", 1:5))`
* `any_of()` - matches if the column exists, but returns no erroif it is not found
  * example: `select(any_of(date_onset, date_death, cardiac_arrest))`
  
In addition to these we can use normal operators such as:

* `c()` - to list several columns
  * example: `select(c(date_onset, hosp_date, gender))`
* `:` - to select consecutive columns
  * example: `select(1:5)`
* `!` - fothe opposite
  * example: `select(!c(date_onset, hosp_date, gender))`
  * This would _not_ select date_onset, hosp_date, gender
* `&` - AND
  * example: `select(matches("date" & "outcome"))`
* `|` - OR
  * example: `select(matches("date" | "outcome"))`

Select can also be used to remove columns, rather than keep, by putting the minus symbol "-" in front of the column name

```{r, eval = T, echo = T}
linelist %>%
  select(-c(date_onset, fever:vomit)) %>% #This will remove date_onset and all columns from fever to vomit
  names()
```

You can also remove a column using **base R** syntax, by defining it as NULL. For example:
```{r, eval = F, echo = T}
linelist$date_onset <- NULL #Deletes column with **base R** syntax
```

```{r quiz1}
quiz(
  question("Which of these column names follows a clean syntax?",
    answer("date hospitalisation"),
    answer("date_of_patient_hospitalisation"),
    answer("date@hospitalisation"),
    answer("date_hosp", correct = TRUE)
  ),
  question("Which of these functions can be used to rename columns?",
           answer("rename()", correct = TRUE),
           answer("clean_names()", correct = TRUE),
           answer("head()"),
           answer("select()", correct = TRUE)
           ),
  question("Why is it useful to follow a similar style nomenclature (all date columns starting *date_*) for column names?",
    answer("It looks good when you output tables and figures"),
    answer("It helps us find relevant columns and makes omissions/errors less likely", correct = TRUE),
    answer("R is very inflexible and only allows certain combinations of words"),
    answer("It allows us to sort the dataset by alphabetical order")
  ),
  question("In which order would you place these functions in order to output only the names of the columns 'date_onset' and 'outcome' from linelist_raw",
           answer("clean_names(), select(date_onset, outcome), names()", correct = TRUE),
           answer("select(date_onset, outcome), clean_names(), names()"),
           answer("clean_names(), select(-c(date_onset, outcome)), names()"),
           answer("clean_names(), select(date_onset, outcome), head()")
           )
   
)
```

Can you write a pipe chain that drops the columns from `lon` to `source` from linelist_raw?

```{r drop_lon_to_source, exercise = TRUE}

```

```{r drop_lon_to_source-hint}
It is good practice to clean your column names, but it is not necessary to in this example. 

Remember, you do not need to specifiy each column name individually that you want to drop between two columns
```

```{r drop_lon_to_source-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal(message = "You have correctly linked the functions in order and displayed the names of the cleaned dataset, good work!")
    # Default to failing grade with feedback
    fail()
  })
```

```{r drop_lon_to_source-solution}
linelist_raw %>%
         select(-c(lon:source))
```

We need to put all columns with a "date" in them into the same nomenclature (*date_*) and then subset linelist_raw to contain these and all symptom columns.
How would you do this using only `clean_names()` and `select()`?

```{r date_symptom_subset, exercise = TRUE}

```

```{r date_symptom_subset-hint}
You will have to combine renaming, a tidyselect helper function and a normal operator within select() to efficiently clean and subset
```

```{r date_symptom_subset-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal(message = "You have correctly linked the functions in order and displayed the names of the cleaned dataset, good work!")
    # Default to failing grade with feedback
    fail()
  })
```

```{r date_symptom_subset-solution}
linelist_raw %>%
  clean_names() %>%
  select(date_infection = infection_date,
         date_hospitalisation = hosp_date,
         starts_with("date_"),
         fever:vomit)
```

## Column creation and transformation

Creating new columns and transforming existing ones is easily done in R, where we recommend using the **dplyr** package function `mutate()` which uses the syntax `NEW = TRANSFORMATION`.

For example, this would create a new column called `new_col` where each row has the value of 10.

```{r eval = F, echo = T}
linelist %>%
  mutate(new_col = 10)
```

You can also reference pre-existing columns to perform calculations. For example, to calculate the Body Mass Index (BMI) we can use the formula BMI = kg/m^2 using the column `ht_cm` and `wt_kg` through:
```{r eval = T, echo = T}
linelist %>%
  mutate(bmi = wt_kg/(ht_cm/100)^2) %>%
  select(wt_kg, ht_cm, bmi) %>%          #This selects just the wt_kg, ht_cm and bmi columns
  head()                                 #This displays the top 6 rows to check
```

In **base** R this would be carried out with
```{r, echo = T, eval = F}
linelist$bmi = linelist$wt_kg / (linelist$ht_cm / 100) ^ 2)
```

We can also create multiple new columns at once, which are separated with a comma and should begin on a new line
```{r eval = T, echo = T}
linelist %>%                       
  mutate(
    new_var_dup    = case_id,             # new column = duplicate/copy another existing column
    new_var_static = 7,                   # you can create static variables that are the same for each row
    new_var_static = new_var_static + 5,  # you can overwrite a column, and it can be a calculation using other variables
    ) %>% 
  select(case_id, hospital, date_hospitalisation, contains("new")) %>%
  head()
```

```{r rhetorical2, echo = FALSE}
question_text(
  "Can you think of a reason why we would create a new column in R, rather than the csv we take the data from?",
  answer_fn(function(value) {
    if (grepl(paste(letters, collapse = "|"), value)) {
      correct("")
    }
  }, )
)
```


```{r quiz2}
quiz(
  question("Which function can be used to create new columns?",
    answer("select()"),
    answer("mutate()", correct = TRUE),
    answer("rename()"),
    answer("clean_names()")
  ))
```

Can you take what you have learned in the previous chapters and create a new column called `age_months` from `age`, and then subset to only include `age`, `age_months` and `gender`? Note, you should ensure that all values in age are the same unit (specified in `age_unit`), and convert according to this.

```{r date_mutate, exercise = TRUE}

```

```{r date_mutate-hint}
You can use ifelse() to carry out different operations based on another value, this is a vectorised version of the if statement, and so will run through each row of a column and return an answer
ifelse(age_unit == "years",   #The condition, if the value in the column age_unit DOES equal years then the function will return...
       age * 12,              #this value, and if the value in column age_unit DOES NOT equal years, then the function will return...
       age                    #the value in age without manipulation
)
```

```{r date_mutate-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal(message = "Great, you have created a new column based and learned about the ifelse() function.")
    # Default to failing grade with feedback
    fail()
  })
```

```{r date_mutate-solution}
linelist %>%
  mutate(age_months = ifelse(age_unit == "years", age * 12, age)) %>%
  select(age, age_months, gender)
```


### Converting column class

Columns contain values that are dates, numbers or logical values (TRUE/FALSE) and will only behave if correctly classified. Trying to sum "2" and "1" of class character will return an error, and summing 2 and 1 of class numeric will return 3.

The class of a column is displayed when we use `skim()` and individually we can check the value of columns with `class()`. For instance, below we can see that this column has been incorrectly assigned as "character". 

```{r, echo = T, eval = T}
class(linelist_raw$age)
```

Can you reassign the class of this column to numeric using `as.numeric()`?

```{r change_class, exercise = TRUE}
linelist_raw %>%
  
```

```{r change_class-hint}
In order to change a value to numeric, you can use the function as.numeric()
```

```{r change_class-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal(message = "Great, you have created a new column based and learned about the ifelse() function.")
    # Default to failing grade with feedback
    fail()
  })
```

```{r change_class-solution}
linelist %>%
    mutate(age = as.numeric(age))
```

Using the same syntax you can convert columns to character with `as.character()` or to logical operators, `as.logical()` or to a factor with `as.factor()` with **base** R, or `as_factor()` from the package **forcats**.

Converting dates is slightly trickier, and it requires careful attention to the format (e.g. "Month/Day/Year" or "Day/Month/Year"). After converting to the class Date, check your data to confirm each value was converted correctly.

### Grouping data

Often your data will be grouped, and so functions such as `mutate()` will behave differently than if the data is not grouped. Additionally, summarising functions such as `mean()`, `min()`, `max()` will calculate by group and not by all the rows.

```{r rhetorical3, echo = FALSE}
question_text(
  "Why might we want to group data?",
  answer_fn(function(value) {
    if (grepl(paste(letters, collapse = "|"), value)) {
      correct("")
    }
  }, )
)
```

```{r, eval = T, echo = T}
# age normalized to mean of ALL rows
linelist %>% 
    summarize(mean_age = mean(age, na.rm = T))

# age normalized to mean of hospital group
linelist %>% 
    group_by(hospital) %>% 
    summarize(mean_age = mean(age, na.rm = T))
```

Can you group outcome by `age_cat` *and* `gender`, then use `count(outcome)` in order to produce a summary table of outcome by age category and gender?

```{r age_sex_group, exercise = TRUE}
linelist %>%
  
```

```{r age_sex_group-hint}
You can include multiple arguments in group_by(), and remember to end your pipe chain with count(outcome).
```

```{r age_sex_group-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal(message = "Great, you have created a new column based and learned about the ifelse() function.")
    # Default to failing grade with feedback
    fail()
  })
```

```{r age_sex_group-solution}
linelist %>% 
  group_by(age_cat, gender) %>% 
  count(outcome)
```


### Transform multiple columns

The function across() allows us to apply a function to everything specified within it. Columns are specified using the `.cols =` function, either individually, or with "tidyselect" helper functions. The function to apply to these columns is then specified with `.fns = ` (note the function is specified _without_ parentheses "()").

```{r, eval = T, echo = T}
linelist %>%
  mutate(across(.cols = c(temp, ht_cm, wt_kg), .fns = as.character))
```

```{r quiz3}
quiz(
  question("What will this pipe chain do?",
    answer("Check the columns temp, ht_cm and wt_kg to see if they are the character class and return a TRUE/FALSE"),
    answer("Check the columns temp, ht_cm and wt_kg to see if they are the character class"),
    answer("Convert the columns temp, ht_cm and wt_kg to character class and make new columns"),
    answer("Convert the columns temp, ht_cm and wt_kg to character class and update existing columns", correct = TRUE)
  ))
```

Can you update the above function using "tidyselect" helper functions to convert any columns that contain "date" to character?

```{r tidyselect_date_character, exercise = TRUE}
linelist_raw %>%
```

```{r tidyselect_date_character-hint}
Remember you can use tidyhelper functions such as "select()"
```

```{r tidyselect_date_character-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal(message = "Great, you have created a new column based and learned about the ifelse() function.")
    # Default to failing grade with feedback
    fail()
  })
```

```{r tidyselect_date_character-solution}
linelist %>%
  mutate(across(.cols = contains("date"), .fns = as.character))
```

### coalesce()

This **dplyr** function allows us to "fill in" missing values with the first available value in an order you specify. For example, you have two vectors, one containing the patient’s village of detection and another containing the patient’s village of residence. You can use coalesce to pick the first non-missing value for each index:

```{r, eval = T, echo = T}
village_detection <- c("a", "b", NA,  NA)
village_residence <- c("a", "c", "a", "d")

village <- coalesce(village_detection, village_residence)
village    # print
```

This works the same way for a dataset

```{r, eval = T, echo = T}
linelist %>% 
  transmute(first_date = coalesce(date_infection, date_onset),#transmute() is the same as mutate(), except it drops everything not specified in the brackets
            date_infection, 
            date_onset) %>% 
  head()
```

```{r rhetorical5, echo = FALSE}
question_text(
  "Can you think of any analysis or programmatic issues that might arise when two distinct columns, and how we might mitigate them?",
  answer_fn(function(value) {
    if (grepl(paste(letters, collapse = "|"), value)) {
      correct("")
    }
  }, )
)
```

### Cumulative math

In your datasets, you may want to take cumulative sum/mean/min/max etc values across all the rows in the dataframe. For example, calculating the cumulative sum of cases across an outbreak or per day can give us an idea of how the infection is progressing. To calculate the cumulative sum across the entire outbreak, we would do the following:

```{r}

linelist %>%                                 #Begin with the case linelist, and then
  count(date_onset) %>%                      #count of rows per day, as column 'n' by default, and then
  mutate(cumulative_cases = cumsum(n)) %>%   #new column, of the cumulative sum at each row, and then
  head(10)                                   #display the first 10 rows

```

Can you use what you have learned in order to produce a cumulative sum (in a column called cumulative_cases) of the epidemic by healthcare setting from linelist?

```{r cumulative_sum, exercise = TRUE}
linelist %>% 

```

```{r cumulative_sum-hint}
Remember to use group_by() 

```

```{r cumulative_sum-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal(message = "Great, it's hard to see because we have 1629 rows, but you have correctly grouped and cumulatively summed by hospital!")
    # Default to failing grade with feedback
    fail()
  })
```

```{r cumulative_sum-solution}
linelist %>% 
  group_by(hospital) %>%
    count(date_onset) %>%
    mutate(cumulative_cases = cumsum(n))
```

### Deduplication

The package **dplyr** has the function  `distinct()` which removes duplicated rows in the dataset, by default it considers all columns though this can be adjusted. Here we will ensure that no rows are 100% duplicates of other rows (evaluated across all columns) in the dataset `linelist_raw`. We are comparing the number of rows in the original and de-duplicated 

```{r, echo = T, eval = T}
nrow(linelist_raw)

linelist_raw %>%
  distinct() %>%
  nrow()
```
As you can see the linelist goes from 6611 rows to 6609 These omitted rows would have been 100% duplicates of other rows.

### Quiz

Now we are going to run through everything we have learned so far in order to convert `linelist_raw` into `linelist`, this will require several steps.

* Cleaning names, both automatically and manually renaming date columns to the clean syntax
* Removing the columns "row_num", "merged_header" and "x28"
* De-duplicating
* Adding in the new column "bmi"
* Converting all date columns to the date class, generation and age to numeric class

```{r linelist_raw_to_linelist, exercise = TRUE}


```

```{r linelist_raw_to_linelist-hint}
You have already done each of these steps individually (and some together), this is a case of remembering how to use rename(), select(), mutate() and a few other functions.

```

```{r linelist_raw_to_linelist-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal(message = "You have strung together numerous functions in order to create a clean dataset, you are well on your way to becoming a data cleaning expert.")
    # Default to failing grade with feedback
    fail()
  })
```

```{r linelist_raw_to_linelist-solution}
linelist_raw %>%
  janitor::clean_names() %>% 
  rename(date_infection       = infection_date,
         date_hospitalisation = hosp_date,
         date_outcome         = date_of_outcome) %>% 
  select(-c(row_num, merged_header, x28)) %>% 
  distinct() %>% 
  mutate(bmi = wt_kg / (ht_cm/100)^2) %>% 
  mutate(across(contains("date"), as.Date), 
         generation = as.numeric(generation),
         age = as.numeric(age))
```


## Re-code values

You will occasionally have to re-code values, this can be due to a number of reasons

* To edit one specific value (e.g. one date in the wrong format)
* To reconcile values not spelled the same
* To create a new column of categorical values
* To create a new column of numeric categories (e.g. age categories)

### Specific values

To change values manually we can use the `recode()` function within `mutate()`. For instance, to fix a date that has been incorrectly included we use the following:
```{r, echo = F, eval = F}
linelist %>%                             #Old value     #New value
  mutate(date_onset = recode(date_onset, "2014-14-15" = "2014-04-15"))
```

Another example of when you would use recode is if you have a column with several different spellings and missing values.

```{r, echo = T, eval = T}
table(linelist_raw$hospital, useNA = "always")  # print table of all unique values, including missing  
```

As you can see, we need to do some manual cleaning in order to correct misspellings. 

```{r, echo = T, eval = T}
linelist_updated <- linelist_raw %>% 
  mutate(hospital = recode(hospital,
                     # for reference: OLD = NEW
                      "Mitylira Hopital"  = "Military Hospital",
                      "Mitylira Hospital" = "Military Hospital",
                      "Military Hopital"  = "Military Hospital",
                      "Port Hopital"      = "Port Hospital",
                      "Central Hopital"   = "Central Hospital",
                      "other"             = "Other",
                      "St. Marks Maternity Hopital (SMMH)" = "St. Mark's Maternity Hospital (SMMH)"
                      ))

table(linelist_updated$hospital, useNA = "always")

```


```{r rhetorical6, echo = FALSE}
question_text(
  "Why would you recode in R rather than manually in the dataset?",
  answer_fn(function(value) {
    if (grepl(paste(letters, collapse = "|"), value)) {
      correct("")
    }
  }, )
)
```

Can you quickly recode the values in the column `gender` from "f" to "Female" and "m" to "Male"? Once this is done, can you also `select()` the column `gender` only and show the first 6 rows with `head()`?

```{r gender_recode, exercise = TRUE}
linelist_raw %>%

```

```{r gender_recode-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal()
    # Default to failing grade with feedback
    fail()
  })
```

```{r gender_recode-solution}
linelist_raw %>%
  mutate(gender  = recode(gender, "f" = "Female",
                          "m" = "Male")) %>%
  select(gender) %>%
  head()
  
```

### Simple logic

We can also re-code based on logical criteria, you can use `replace()` within `mutate()` and use it with logical conditions in order to specify which rows to change using the following general syntax

```{r, eval = F, echo = T}
mutate(col_to_change = replace(col_to_change, criteria for rows, new value))
```

For instance, if you know a row that is identified with a certain id has the wrong value (such as gender), you can correct this using a logical condition. 
```{r, eval = F, echo = T}
linelist %>% 
  mutate(gender = replace(gender, case_id == "2195", "Female"))
```

This will find the row with the `case_id` of "2195" and change the gender to "Female".

Another useful tool for simple logic is `ifelse()`, `if_else()` and `case_when()`. These "if else" commands are simplified versions of an `if` and `else` programming statement with the general syntax of
```{r, eval = F, echo = T}
ifelse(condition, value to return if condition evaluates to TRUE, value to return if condition evaluates to FALSE)
```

Here we are creating a column `source_known` column where the value of a row is "known" if the row's value in column `source` is _not_ missing. If it _is_ missing then it will be set to "unknown"

```{r, eval = F, echo = T}
linelist %>% 
  mutate(source_known = ifelse(!is.na(source), "known", "unknown"))
```

if_else() is a function from **dplyr** that handles dates. Note that if the "true" value is a date, the "false" value must also qualify a date, hence the use of `NA_real_` instead of `NA`.
```{r, eval = F, echo = T}
linelist %>% 
  mutate(date_death = if_else(outcome == "Death", date_outcome, NA_real_))
```

```{r quiz4}
quiz(
  question("Which of these simple logical statements would replace 'Other' with 'Unidentified' in the column 'hospital'?",
    answer("mutate(hospital = ifelse(hospital == 'Other', 'Unidentified', hospital))", correct = TRUE),
    answer("mutate(hospital = ifelse(hospital == 'Unidentified', 'Other', hospital))"),
    answer("mutate(hospital = ifelse(hospital == 'Other', 'Unidentified', 'Identified'))"),
    answer("mutate(hospital = ifelse(Other == 'hospital', 'Unidentified', hospital))")
  ))
```

### Complex logic

Complex logic takes simple logic to the next level and allows us to input several different criteria. For example, if you are re-coding into several new groups you can use **dplyr**'s `case_when()` function. 

`case_when()` command consists of logical statements and outcomes seperated by a "tilde" `~`. The logic criteria are on the left and the values on the right with statements seperated by commas.

For example, here we utilize the columns `age` and `age_unit` to create a column `age_years`:

```{r, echo = T, eval = F}
linelist <- linelist %>% 
  mutate(age_years = case_when(
            age_unit == "years"  ~ age,       # if age is given in years
            age_unit == "months" ~ age/12,    # if age is given in months
            is.na(age_unit)      ~ age,       # if age unit is missing, assume years
            TRUE                 ~ NA_real_)) # any other circumstance, assign missing
```

The criteria are applied in the order the `case_when()` statement is written. So if the criteria is met by the first argument (here, `age_unit` == "years"), then the remaining criteria are not tested. It is therefore important to order your arguments correctly, as in when writing a pipe chain `%>%`, from most specific to generic.

Along those lines, in your final statement, place TRUE on the left-side, which will capture any row that did not meet any of the previous criteria. The right-side of this statement could be assigned a value like “check me!” or missing.

**DANGER: Values on the right-side must all be the same class - either numeric, character, date, logical, etc. To assign missing (NA), you may need to use special variations of NA such as NA_character_, NA_real_ (for numeric or POSIX), and as.Date(NA). Read more in Working with [dates](https://www.epirhandbook.com/en/working-with-dates.html).**

Here we want to look at the temperatures of people recorded in the dataset. However, upon first visualization we can see that there is some discordence in the dataset.

```{r, echo = F, eval = T, error = FALSE}
ggplot(data = linelist_raw) +
    geom_histogram(aes(x = temp), binwidth = 1) +
  scale_x_continuous(limits = c(30, 110), breaks = seq(30, 110, by = 10)) +
      labs(x = "Temperature", y = "Count")
```

Most of the values are located between 35 and 41, as expected if we were recording temperatures in °C, however some values are around 100, and so we can deduce that these have been incorrectly recorded in °F. Using the formula, `°C = (°F − 32) * 5/9`, can you use complex logic to convert values that are above 90 and below 120 to Celcius?

```{r temp_convert_logic, exercise = TRUE}
linelist %>%
```

```{r temp_convert_logic-hint}
You will need to use case_when and greater than (temp >) and less than (temp <) combined with the and (&)
```

```{r temp_convert_logic-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal(message = "You've successfully used complex logic, great work.")
    # Default to failing grade with feedback
    fail()
  })
```

```{r temp_convert_logic-solution}
linelist %>%
    mutate(temp = case_when(temp > 90 & temp < 120 ~ (temp - 32) * 5/9,
                            TRUE ~ temp))
  
```

### Missing values

Missing values are an ever present facet of dealing with real world data, and it is important to correctly identify and handle them in order to highlight data gaps and adjust our analysis accordingly. There are several inbuilt functions for dealing with missing data, depending on the scenario and the class of data.

```{r rhetorical7, echo = FALSE}
question_text(
  "Why is it important to correctly account for missing data? Can you think about how this may impact our understanding of the data and any analyses that are performed?",
  answer_fn(function(value) {
    if (grepl(paste(letters, collapse = "|"), value)) {
      correct("")
    }
  }, )
)
```

To change missing values (`NA`) to a specific value, such as "Missing", we can use the **dplyr** function `replace_na()` with `mutate()`

```{r}
linelist <- linelist %>% 
  mutate(hospital = replace_na(hospital, "Missing"))
```

Factors are R’s way to handle ordered values such as c("First", "Second", "Third") or to set the order that values (e.g. hospitals) appear in tables and plots. If your data are of the class Factor and you try to convert NA to “Missing” by using `replace_na()`, you will get this error: invalid factor level, NA generated. You have tried to add “Missing” as a value, when it was not defined as a possible level of the factor, and it was rejected.

The easiest way to solve this is to use the **forcats** function `fct_explicit_na()` which converts a column to class factor, and converts NA values to the character “(Missing)”.

```{r}
linelist %>% 
  mutate(hospital = fct_explicit_na(hospital))
```

To convert a specific value to NA, use **dplyr**’s `na_if()`. The command below performs the opposite operation of `replace_na()`. In the example below, any values of “Missing” in the column hospital are converted to NA.

```{r}
linelist <- linelist %>% 
  mutate(hospital = na_if(hospital, "Missing"))
```

However, `na_if()` cannot be used for logical criteria (e.g. “all values > 99”) - use `replace()` or `case_when()` for this:

```{r}
# Convert temperatures above 40 to NA 
linelist <- linelist %>% 
  mutate(temp = replace(temp, temp > 40, NA))

# Convert onset dates earlier than 1 Jan 2000 to missing
linelist <- linelist %>% 
  mutate(date_onset = replace(date_onset, date_onset > as.Date("2000-01-01"), NA))
```

We are now going to practice these different methods of replacing NA values. In `linelist` can you do the following:

* Convert NA values in the `age` column to "Age not recorded"
* If values in `bmi` are below 10 or above 40, replace them with NA

```{r NA_practice, exercise = TRUE}

```

```{r NA_practice-hint}
You will need to use both na_if() and replace(), and a few logical operators ("|", "<", ">")
```

```{r NA_practice-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal()
    # Default to failing grade with feedback
    fail()
  })
```

```{r NA_practice-solution}
linelist %>%
 mutate(age = na_if(age, "Age not recorded"),
        bmi = replace(bmi, bmi < 10 | bmi > 40, NA))
```

## Numerical categories

There are numerous reasons why you may want to categorise numeric values, such as for age groups, lab values etc. R has several ways of doing this.

* `age_categories()`, from the **epikit** package
* `cut()` from **base R**
* `case_when()`
* quantile breaks with `quantile()` and `ntile()`

### age_categories()

With the **epikit** package, you can use the `age_categories()` function to easily categorize and label numeric columns (note: this function can be applied to non-age numeric variables too). As a bonus, the output column is automatically an ordered factor.

Here are the required inputs:

* A numeric vector (column)
* The `breakers = ` argument, provide a numeric vector of break points for new groups.

For example

```{r, echo = T, eval = T}
linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(             # create new column
      age_years,                            # numeric column to make groups from
      breakers = c(0, 5, 10, 15, 20,        # break points
                   30, 40, 50, 60, 70)))

# Display the table
table(linelist$age_cat, useNA = "always")
```

Break values specified are by default the lower bounds, here the categorisation occurs so that the left/lower side is "open" and "inclusive". . You can adjust how the labels are displayed with `separator = `, with the default as "-". 

You may also want to set an upper limit, this will categorise any value above the last breaker as `NA`. This is doing using `ceiling = TRUE`.

```{r, echo = T, eval = T}
linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(             # create new column
      age_years,                            # numeric column to make groups from
      breakers = c(0, 5, 10, 15, 20,        # break points
                   30, 40, 50, 60, 70),
      ceiling = TRUE))

# Display the table
table(linelist$age_cat, useNA = "always")
```

Alternatively, instead of using `breakers = ` you can provide `lower = `, `upper = ` and `by = `:

```{r, echo = T, eval = T}
linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(             # create new column
      age_years,                            # numeric column to make groups from
      lower = 0,
      upper = 70,
      by = 5))

# Display the table
table(linelist$age_cat, useNA = "always")
```

```{r quiz5}
quiz(
  question("Which of these age_categories() specifications would create breaks at 0, 25, 50 and 75?",
    answer("age_categories(age_years, breakers = c(0, 25, 50, 75))", correct = TRUE),
    answer("age_categories(age_years, lower = 0, upper = 75, by = 5)", correct = TRUE),
    answer("age_categories(age_years, breakers = c(0, 25, 50, 75), ceiling = FALSE", correct = TRUE),
    answer("age_categories(age_years, breakers = 25, lower = 0, upper  = 75)")
  ))
```

### cut()

`cut()` is a **base** R alternative to `age_categories()`. The basic syntax is to first provide a numeric culumn to be cut (`age_years`), and then the `breaks = ` argument which is a numeric vector `c()` of break points. 

By default, the categorisation occurs so the right/upper side is "open" and "inclusive", *this is the opposite behavior to `age_categories()` function*. You can reverse this behavior, and so align it with the `age_categories()` function through adding the `right = TRUE` argument.

Thus, by default, “0” values are excluded from the lowest group, and categorized as NA! “0” values could be infants coded as age 0 so be careful! To change this, add the argument `include.lowest = TRUE` so that any “0” values will be included in the lowest group. The automatically-generated label for the lowest category will then be “[A],B]”. Note that if you include the `include.lowest = TRUE` argument *and* `right = TRUE`, the extreme inclusion will now apply to the highest break point value and category, not the lowest.

```{r, echo = T, eval = T}
# Create new variable, by cutting the numeric age variable
# lower break is excluded but upper break is included in each category
linelist <- linelist %>% 
  mutate(
    age_cat = cut(
      age_years,
      breaks = c(0, 5, 10, 15, 20,
                 30, 50, 70, 100),
      include.lowest = TRUE         # include 0 in lowest group
      ))

# tabulate the number of observations per group
table(linelist$age_cat, useNA = "always")
```

**It is very important to check your work here, do so by cross-tabulating the numeric and category columns**

You may want to assign NA values a label such as “Missing”. Because the new column is class Factor (restricted values), you cannot simply mutate it with `replace_na()`, as this value will be rejected. Instead, use `fct_explicit_na()` from the **forcats** package, as explained in the Factors page.

```{r, echo = T, eval = T}
linelist <- linelist %>% 
  
  # cut() creates age_cat, automatically of class Factor      
  mutate(age_cat = cut(
    age_years,
    breaks = c(0, 5, 10, 15, 20, 30, 50, 70, 100),          
    right = FALSE,
    include.lowest = TRUE,        
    labels = c("0-4", "5-9", "10-14", "15-19", "20-29", "30-49", "50-69", "70-100")),
         
    # make missing values explicit
    age_cat = fct_explicit_na(
      age_cat,
      na_level = "Missing age")  # you can specify the label
  )    

# table to view counts
table(linelist$age_cat, useNA = "always")
```

Can you write some code to create a new column `temp_cat` to convert values in `temp` to the following categories:

* Less than 38 - "No fever"
* Greater than or equal to 38 & less than 39.4 - "Low grade fever"
* Greater than or equal to 39.4 - "High grade fever"

set the lower bound to 0, and then display only the columns `temp` and `temp_cat`?

```{r cut_temp, exercise = TRUE}

```

```{r cut_temp-hint}
You will need to use the function cut() and specify the correct breaks, and remember that cut() occurs on the right side, and age_categories() the left, so if you are using cut() you may also need to include the argument right = FALSE 
```

```{r cut_temp-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal()
    # Default to failing grade with feedback
    fail()
  })
```

```{r cut_temp-solution}
  linelist %>% 
  mutate(temp_cat = cut(
    temp,
    breaks = c(0, 38, 39.4, 45),          
    right = FALSE,
    labels = c("No fever", "Low grade fever", "High grade fever"))) %>%
  select(temp, temp_cat)
```

### Quantile breaks

Quantiles, or percentiles, typically refer to a value below which a proportion of values fall. For example, the 95th percentile of ages in `linelist` would be the age below which 95% of the ages fall. 

However in common speech, “quartiles” and “deciles” can also refer to the groups of data as equally divided into 4, or 10 groups (note there will be one more break point than group).

To get quantile break points, you can use quantile() from the **stats** package from **base** R. You provide a numeric vector (e.g. a column in a dataset) and vector of numeric probability values ranging from 0 to 1.0. The break points are returned as a numeric vector. Explore the details of the statistical methodologies by entering ?quantile.

* If your input numeric vector has any missing values it is best to set na.rm = TRUE
* Set names = FALSE to get an un-named numeric vector

``` {r, echo = T, eval = T}
quantile(linelist$age_years,               # specify numeric vector to work on
  probs = c(0, .25, .50, .75, .90, .95),   # specify the percentiles you want
  na.rm = TRUE)                            # ignore missing values 
```

You can use the results of `quantile()` as break points in `age_categories()` or `cut()`. Below we create a new column deciles using `cut()` where the breaks are defined using `quantiles()` on age_years. Below, we display the results using `tabyl()` from janitor so you can see the percentages (see the Descriptive tables page). Note how they are not exactly 10% in each group.

```{r, echo = T, eval = T}
linelist %>%                                # begin with linelist
  mutate(deciles = cut(age_years,           # create new column decile as cut() on column age_years
    breaks = quantile(                      # define cut breaks using quantile()
      age_years,                               # operate on age_years
      probs = seq(0, 1, by = 0.1),             # 0.0 to 1.0 by 0.1
      na.rm = TRUE),                           # ignore missing values
    include.lowest = TRUE)) %>%             # for cut() include age 0
  janitor::tabyl(deciles)                   # pipe to table to display
```

Can you create a quantile break that gives us `linelist$age_years` broken down in 10% increments from 0 to 1? Remember to remove `NA` values. 

```{r quant_break, exercise = TRUE}

```

```{r quant_break-hint}
Remember you can specify the probs either manually, or by using seq()
```

```{r quant_break-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal()
    # Default to failing grade with feedback
    fail()
  })
```

```{r quant_break-solution}
quantile(linelist$age_years, probs = seq(0, 1, by = 0.1), na.rm = TRUE)
```

### Evenly sized groups

Another tool to make numeric groups is the **dplyr** function `ntile()` which breaks your data into evenly sized groups - *be aware that unlike in `quantile()` the same value could appear in more than one group.* Firstly you provided the numeric vector (the column) and the number of groups with the values in the new column created being the group "numbers" not the range of values themselves (as when you use `cut()`).

```{r, echo = T, eval = T}
# make groups with ntile()
ntile_data <- linelist %>% 
  mutate(even_groups = ntile(age_years, 10))

# make table of counts and proportions by group
ntile_table <- ntile_data %>% 
  janitor::tabyl(even_groups)
  
# attach min/max values to demonstrate ranges
ntile_ranges <- ntile_data %>% 
  group_by(even_groups) %>% 
  summarize(
    min = min(age_years, na.rm=T),
    max = max(age_years, na.rm=T)
  )

# combine and print - note that values are present in multiple groups
left_join(ntile_table, ntile_ranges, by = "even_groups")

```

```{r rhetorical8, echo = FALSE}
question_text(
  "Can you think of a situation, other than age, where we might want to split the data into evenly sized groups?",
  answer_fn(function(value) {
    if (grepl(paste(letters, collapse = "|"), value)) {
      correct("")
    }
  }, )
)
```

## Filter rows

A typical cleaning step after cleaning columns and recoding values is to filter the dataset to specific rows with the **dplyr** function `filter()`.

### Simple filter

The simplest way of filtering, is to use a logical condition ("==", "!=", ">", "<", etc), so that only rows where the logical statement is `TRUE` are kept. For example here, we are only keeping rows where the gender is equal to "f".

```{r, echo = T, eval = T}
nrow(linelist)

linelist %>% 
  filter(gender == "f") %>%
  nrow()
```

From the reduction in rows you can see that we have subset the dataset.

```{r quizage}
quiz(
  question("Which of these uses of simple logic would enable the filter to remove any ages greater than 90?",
    answer("filter(age_years != 90)"),
    answer("filter(age_years > 90)"),
    answer("filter(age_years < 90)", correct = TRUE),
    answer("filter(age_years == 90)")
  ))
```

### Filter out missing values

A common use of filtering is to remove rows that have missing values. This can either be done for any missing values in _any_ column, by not specifiying any arguments in the **tidyr** function `drop_na()`, or specific columns by including them within `drop_na()`.

```{r, echo = T, eval = T}
linelist %>% 
  drop_na(case_id, age_years)  # drop rows with missing values for case_id or age_years
```

Can you now write a pipe chain to filter out any rows with a `bmi` of more than 20, and then drop any rows that have NA values in any column between fever and vomit, and then show the first 6 rows with `head()`?

```{r filter_row_first, exercise = TRUE}

```

```{r filter_row_first-hint}
Remember to use logical operators, and that you can specify a group of consective columns with ":".
```

```{r filter_row_first-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal()
    # Default to failing grade with feedback
    fail()
  })
```

```{r filter_row_first-solution}
  linelist %>% 
  filter(bmi < 20) %>%
  drop_na(fever:vomit) %>%
  head()
```

### Filter by row number

You can also filter by row number, this is done using the **dplyr** function `row_number()`. Here you will often use the operator `%in%` to specify all numbers within a supplied vector. For example, this filter command would remove all rows between 2 and 20 `filter(row_number() %in% 2:20)`.

Can you write a filter that will remove all **odd** numbered rows from linelist, between 1 and 100 (i.e 1, 3, 5,...,99)?

```{r filter_row_number, exercise = TRUE}

```

```{r filter_row_number-hint}
You do not need to manually write the numbers, you can use seq() to create a vector of all the odd numbers between 1 and 100.
```

```{r filter_row_number-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal()
    # Default to failing grade with feedback
    fail()
  })
```

```{r filter_row_number-solution}
  linelist %>% 
  filter(row_number() %in% seq(1, 100, by = 2))
```

## Row-wise calculations

We may want to perform a calculation within a row, and to do so we can use `rowwise()` from **dplyr**. 

For example, this code applies `rowwise()` and then creates a new column that sums the number of the specified symptom columns that have value “yes”, for each row in the linelist. The columns are specified within sum() by name within a vector `c()`. `rowwise()` is essentially a special kind of `group_by()`, so it is best to use `ungroup()` when you are done.

```{r, echo = T, eval = T}
linelist %>%
  rowwise() %>%
  mutate(num_symptoms = sum(c(fever, chills, cough, aches, vomit) == "yes")) %>% 
  ungroup() %>% 
  select(fever, chills, cough, aches, vomit, num_symptoms) # for display

```

As you specify the column to evaluate, you may want to use the “tidyselect” helper functions.

Can you write a function that does the following?

* Applies `rowwise()` so the following operation (`sum()`) is applied within each row (not summing entire columns)
* Creates new column `num_NA_dates`, which contains the number of `NA` values in the columns `date_infection`, `date_onset`, `date_hospitalisation` and `date_outcome`
* `ungroup()` to remove the effects of `rowwise()` for subsequent steps
* To `select()` and display, using `head()`, all columns which have "date_" in their name

You could also provide other functions, such as max() to get the latest or most recent date for each row:

```{r rowwise_calc, exercise = TRUE}

```

```{r rowwise_calc-hint}
Remember, for evaluating whether a value is NA, we use "is.na" rather than "== NA". 
```

```{r rowwise_calc-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal()
    # Default to failing grade with feedback
    fail()
  })
```

```{r rowwise_calc-solution}
linelist %>%
    rowwise() %>%
    mutate(num_NA_dates = sum(is.na(c(date_infection, date_onset, date_hospitalisation, date_outcome)))) %>%
  select(contains("date")) %>%
  head()
```

## Arrange and sort

The **dplyr** function `arrange()` allows us to sort or order rows by column values. List the columns in the order they should be sorted on, and specify `.by_group = TRUE` if you want the sorting to occur by any groupings in the data.

By default the column will be sorted in "ascending" order, but you can change this to "descending" by wrapping it with `desc()`.

Sorting data with `arrange()` is particularly useful when making Tables for presentation, using `slice()` to take the “top” rows per group, or setting factor level order by order of appearance.

For example, to sort the our linelist rows by hospital, then by `date_onset` in descending order, we would use:

```{r, echo = T, eval = T}
linelist %>% 
  drop_na(date_onset) %>%                     #Remember to drop NA values
   arrange(hospital, desc(date_onset)) %>%    #the function "desc()" sorts in descending order
   select(case_id, hospital, date_onset)
```

Can you now arrange the column `source` in `linelist` by `date_infection` in ascending order *and* `date_onset` in descending order, then only display rows where `gender == "m"` and the columns `gender`, `date_infection` and `date_onset`? Remember to drop `NA` values from the columns you are sorting by.

```{r arrange_filter, exercise = TRUE}

```

```{r arrange_filter-hint}
Take this step by step, you have successfully completed all these steps individually, it is just a case of tying everything you have learned together!
```

```{r arrange_filter-check}
  grade_this({
    # Automatically pass if .result equal to .solution
    pass_if_equal()
    # Default to failing grade with feedback
    fail()
  })
```

```{r arrange_filter-solution}
linelist %>% 
  drop_na(date_infection, date_onset) %>%
   arrange(source, date_infection, desc(date_onset)) %>%
  filter(gender == "m") %>%
   select(gender, date_infection, date_onset)
```


